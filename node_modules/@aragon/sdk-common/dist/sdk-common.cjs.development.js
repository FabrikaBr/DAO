'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var bytes = require('@ethersproject/bytes');

function isProposalId(propoosalId) {
  var regex = new RegExp(/^0x[A-Fa-f0-9]{40}_0x[A-Fa-f0-9]{1,64}$/i);
  return regex.test(propoosalId);
}

/** Decodes a hex string and returns it as a buffer */
function hexToBytes(hexString) {
  if (!hexString) return new Uint8Array();else if (!/^(0x)?[0-9a-fA-F]*$/.test(hexString)) {
    throw new Error("Invalid hex string");
  } else if (hexString.length % 2 !== 0) {
    throw new Error("The hex string has an odd length");
  }
  hexString = strip0x(hexString);
  var bytes = [];
  for (var i = 0; i < hexString.length; i += 2) {
    bytes.push(parseInt(hexString.substring(i, i + 2), 16));
  }
  return Uint8Array.from(bytes);
}
/** Encodes a buffer into a hex string with the "0x" prefix */
function bytesToHex(buff, skip0x) {
  var bytes = [];
  for (var i = 0; i < buff.length; i++) {
    if (buff[i] >= 16) bytes.push(buff[i].toString(16));else bytes.push("0" + buff[i].toString(16));
  }
  if (skip0x) return bytes.join("");
  return "0x" + bytes.join("");
}
/** Encodes the given big integer as a 32 byte big endian buffer */
function bigIntToBuffer(number) {
  var hexNumber = number.toString(16);
  while (hexNumber.length < 64) hexNumber = "0" + hexNumber;
  return hexToBytes(hexNumber);
}
/** Encodes the given big integer as a 32 byte little endian buffer */
function bigIntToLeBuffer(number) {
  return bigIntToBuffer(number).reverse();
}
/** Transforms the given (big endian) buffer into a big int */
function bufferToBigInt(bytes) {
  // Ensure that it is a buffer
  bytes = Buffer.from(bytes);
  return BigInt(ensure0x(bytes.toString("hex")));
}
/** Transforms the given (little endian) buffer into a endian big int */
function bufferLeToBigInt(bytes) {
  bytes = Buffer.from(bytes);
  return bufferToBigInt(bytes.reverse());
}
function ensure0x(value) {
  return value.startsWith("0x") ? value : "0x" + value;
}
function strip0x(value) {
  return value.startsWith("0x") ? value.substring(2) : value;
}
/**
 * Encodes a 0-1 ratio within the given digit precision for storage on a smart contract
 *
 * @export
 * @param {number} ratio
 * @param {number} digits
 * @return {*}  {bigint}
 */
function encodeRatio(ratio, digits) {
  if (ratio < 0 || ratio > 1) {
    throw new Error("The ratio value should range between 0 and 1");
  } else if (!Number.isInteger(digits) || digits < 1 || digits > 15) {
    throw new Error("The number of digits should range between 1 and 15");
  }
  return Math.round(ratio * Math.pow(10, digits));
}
/**
 * Decodes a value received from a smart contract to a number with
 *
 * @export
 * @param {bigint} onChainValue
 * @param {number} digits
 * @return {*}  {number}
 */
function decodeRatio(onChainValue, digits) {
  if (!Number.isInteger(digits) || digits < 1 || digits > 15) {
    throw new Error("The number of digits should be a positive integer between 1 and 15");
  } else if (onChainValue > Math.pow(10, digits)) {
    throw new Error("The value is out of range");
  }
  return Number(onChainValue) / Math.pow(10, digits);
}
/** Encodes the particles of a proposalId into a globally unque value for subgraph */
function encodeProposalId(pluginAddress, id) {
  if (!/^0x[A-Fa-f0-9]{40}$/.test(pluginAddress)) {
    throw new Error("Invalid address");
  }
  return pluginAddress + "_0x" + id.toString(16);
}
/** Decodes a proposalId from subgraph and returns the original pluginAddress and the nonce */
function decodeProposalId(proposalId) {
  if (!isProposalId(proposalId)) {
    throw new Error("Invalid proposalId");
  }
  var matchedRegexResult = proposalId.match(/^(0x[A-Fa-f0-9]{40})_(0x[A-Fa-f0-9]{1,64})$/) || [];
  if (matchedRegexResult.length !== 3) {
    throw new Error("Could not parse the proposal ID");
  }
  return {
    pluginAddress: matchedRegexResult[1],
    id: parseInt(strip0x(matchedRegexResult[2]), 16)
  };
}
/** Gets the extended version of a proposal id from the compact one */
var getExtendedProposalId = function getExtendedProposalId(proposalId) {
  if (!proposalId.match(/^(0x[A-Fa-f0-9]{40})_(0x[A-Fa-f0-9]{1,64})$/)) {
    throw new Error("Invalid proposalId");
  }
  var splits = proposalId.split("_");
  return splits[0].toLowerCase() + "_" + bytes.hexZeroPad(splits[1], 32);
};
/** Gets the compact version of a proposal id from the extended one */
var getCompactProposalId = function getCompactProposalId(proposalId) {
  if (!proposalId.match(/^(0x[A-Fa-f0-9]{40})_(0x[A-Fa-f0-9]{1,64})$/)) {
    throw new Error("Invalid proposalId");
  }
  var splits = proposalId.split("_");
  return splits[0].toLowerCase() + "_0x" + parseInt(splits[1]).toString(16);
};
/** Transforms an array of booleans into a bitmap big integer */
function boolArrayToBitmap(bools) {
  if (!bools || !bools.length) return BigInt(0);else if (bools.length > 256) throw new Error("The array is too big");
  var result = BigInt(0);
  for (var i = 0; i < 256; i++) {
    if (!bools[i]) continue;
    result |= BigInt(1) << BigInt(i);
  }
  return result;
}
/** Transforms an array of booleans into a bitmap big integer */
function bitmapToBoolArray(bitmap) {
  if (bitmap >= BigInt(1) << BigInt(256)) {
    throw new Error("The bitmap value is too big");
  }
  var result = [];
  for (var i = 0; i < 256; i++) {
    var mask = BigInt(1) << BigInt(i);
    result.push((bitmap & mask) != BigInt(0));
  }
  return result;
}

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var SdkError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(SdkError, _Error);
  function SdkError(message, cause) {
    var _this;
    _this = _Error.call(this, message) || this;
    if (typeof cause === "string") {
      _this.cause = cause;
    } else if (cause instanceof Error) {
      _this.cause = cause.message;
    }
    return _this;
  }
  return SdkError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
var TimeoutError = /*#__PURE__*/function (_SdkError) {
  _inheritsLoose(TimeoutError, _SdkError);
  function TimeoutError(message, cause) {
    return _SdkError.call(this, message ? message : "Time out", cause) || this;
  }
  return TimeoutError;
}(SdkError);
var UnsupportedProtocolError = /*#__PURE__*/function (_SdkError2) {
  _inheritsLoose(UnsupportedProtocolError, _SdkError2);
  function UnsupportedProtocolError(protocol, cause) {
    return _SdkError2.call(this, "Unsupported protocol: " + protocol, cause) || this;
  }
  return UnsupportedProtocolError;
}(SdkError);
var GraphQLError = /*#__PURE__*/function (_SdkError3) {
  _inheritsLoose(GraphQLError, _SdkError3);
  function GraphQLError(model, cause) {
    return _SdkError3.call(this, "Cannot fetch the " + model + " data from GraphQL", cause) || this;
  }
  return GraphQLError;
}(SdkError);
var IpfsError = /*#__PURE__*/function (_SdkError4) {
  _inheritsLoose(IpfsError, _SdkError4);
  function IpfsError(cause) {
    return _SdkError4.call(this, "Cannot add or get data from ipfs", cause) || this;
  }
  return IpfsError;
}(SdkError);
var InvalidAddressOrEnsError = /*#__PURE__*/function (_SdkError5) {
  _inheritsLoose(InvalidAddressOrEnsError, _SdkError5);
  function InvalidAddressOrEnsError(cause) {
    return _SdkError5.call(this, "Invalid address or ENS", cause) || this;
  }
  return InvalidAddressOrEnsError;
}(SdkError);
var InvalidAddressError = /*#__PURE__*/function (_SdkError6) {
  _inheritsLoose(InvalidAddressError, _SdkError6);
  function InvalidAddressError(cause) {
    return _SdkError6.call(this, "Invalid address", cause) || this;
  }
  return InvalidAddressError;
}(SdkError);
var InvalidCidError = /*#__PURE__*/function (_SdkError7) {
  _inheritsLoose(InvalidCidError, _SdkError7);
  function InvalidCidError(cause) {
    return _SdkError7.call(this, "The value does not contain a valid CiD", cause) || this;
  }
  return InvalidCidError;
}(SdkError);
var InvalidProposalIdError = /*#__PURE__*/function (_SdkError8) {
  _inheritsLoose(InvalidProposalIdError, _SdkError8);
  function InvalidProposalIdError(cause) {
    return _SdkError8.call(this, "Invalid proposal ID", cause) || this;
  }
  return InvalidProposalIdError;
}(SdkError);
var NoProviderError = /*#__PURE__*/function (_SdkError9) {
  _inheritsLoose(NoProviderError, _SdkError9);
  function NoProviderError(cause) {
    return _SdkError9.call(this, "A web3 provider is needed", cause) || this;
  }
  return NoProviderError;
}(SdkError);
var NoSignerError = /*#__PURE__*/function (_SdkError10) {
  _inheritsLoose(NoSignerError, _SdkError10);
  function NoSignerError(cause) {
    return _SdkError10.call(this, "A signer is needed", cause) || this;
  }
  return NoSignerError;
}(SdkError);
var UnexpectedActionError = /*#__PURE__*/function (_SdkError11) {
  _inheritsLoose(UnexpectedActionError, _SdkError11);
  function UnexpectedActionError(cause) {
    return _SdkError11.call(this, "The received action is different from the expected one", cause) || this;
  }
  return UnexpectedActionError;
}(SdkError);
var NoTokenAddress = /*#__PURE__*/function (_SdkError12) {
  _inheritsLoose(NoTokenAddress, _SdkError12);
  function NoTokenAddress(cause) {
    return _SdkError12.call(this, "A token address is needed", cause) || this;
  }
  return NoTokenAddress;
}(SdkError);
var NoDaoFactory = /*#__PURE__*/function (_SdkError13) {
  _inheritsLoose(NoDaoFactory, _SdkError13);
  function NoDaoFactory(cause) {
    return _SdkError13.call(this, "A dao factory address is needed", cause) || this;
  }
  return NoDaoFactory;
}(SdkError);
var NoPluginRepoRegistry = /*#__PURE__*/function (_SdkError14) {
  _inheritsLoose(NoPluginRepoRegistry, _SdkError14);
  function NoPluginRepoRegistry(cause) {
    return _SdkError14.call(this, "A plugin repo registry address is needed", cause) || this;
  }
  return NoPluginRepoRegistry;
}(SdkError);
var NoDaoRegistry = /*#__PURE__*/function (_SdkError15) {
  _inheritsLoose(NoDaoRegistry, _SdkError15);
  function NoDaoRegistry(cause) {
    return _SdkError15.call(this, "A dao registry address is needed", cause) || this;
  }
  return NoDaoRegistry;
}(SdkError);
var IpfsPinError = /*#__PURE__*/function (_SdkError16) {
  _inheritsLoose(IpfsPinError, _SdkError16);
  function IpfsPinError(cause) {
    return _SdkError16.call(this, "Failed to pin data on IPFS", cause) || this;
  }
  return IpfsPinError;
}(SdkError);
var ProposalCreationError = /*#__PURE__*/function (_SdkError17) {
  _inheritsLoose(ProposalCreationError, _SdkError17);
  function ProposalCreationError(cause) {
    return _SdkError17.call(this, "Failed to create proposal", cause) || this;
  }
  return ProposalCreationError;
}(SdkError);
var MissingExecPermissionError = /*#__PURE__*/function (_SdkError18) {
  _inheritsLoose(MissingExecPermissionError, _SdkError18);
  function MissingExecPermissionError(cause) {
    return _SdkError18.call(this, "No plugin requests EXECUTE_PERMISSION", cause) || this;
  }
  return MissingExecPermissionError;
}(SdkError);
var IpfsFetchError = /*#__PURE__*/function (_SdkError19) {
  _inheritsLoose(IpfsFetchError, _SdkError19);
  function IpfsFetchError(cause) {
    return _SdkError19.call(this, "Failed to fetch data from IPFS", cause) || this;
  }
  return IpfsFetchError;
}(SdkError);
var InvalidVotingModeError = /*#__PURE__*/function (_SdkError20) {
  _inheritsLoose(InvalidVotingModeError, _SdkError20);
  function InvalidVotingModeError(cause) {
    return _SdkError20.call(this, "Invalid voting mode", cause) || this;
  }
  return InvalidVotingModeError;
}(SdkError);
var UpdateAllowanceError = /*#__PURE__*/function (_SdkError21) {
  _inheritsLoose(UpdateAllowanceError, _SdkError21);
  function UpdateAllowanceError(cause) {
    return _SdkError21.call(this, "Could not define a minimum allowance", cause) || this;
  }
  return UpdateAllowanceError;
}(SdkError);
var InvalidPrecisionError = /*#__PURE__*/function (_SdkError22) {
  _inheritsLoose(InvalidPrecisionError, _SdkError22);
  function InvalidPrecisionError(cause) {
    return _SdkError22.call(this, "Invalid precision, number must be an integer greater than 0", cause) || this;
  }
  return InvalidPrecisionError;
}(SdkError);
var FailedDepositError = /*#__PURE__*/function (_SdkError23) {
  _inheritsLoose(FailedDepositError, _SdkError23);
  function FailedDepositError(cause) {
    return _SdkError23.call(this, "Failed to deposit", cause) || this;
  }
  return FailedDepositError;
}(SdkError);
var AmountMismatchError = /*#__PURE__*/function (_SdkError24) {
  _inheritsLoose(AmountMismatchError, _SdkError24);
  function AmountMismatchError(expected, received, cause) {
    return _SdkError24.call(this, "Deposited amount mismatch. Expected: " + expected + ", received: " + received, cause) || this;
  }
  return AmountMismatchError;
}(SdkError);
var UnsupportedNetworkError = /*#__PURE__*/function (_SdkError25) {
  _inheritsLoose(UnsupportedNetworkError, _SdkError25);
  function UnsupportedNetworkError(network, cause) {
    return _SdkError25.call(this, "Unsupported network: " + network, cause) || this;
  }
  return UnsupportedNetworkError;
}(SdkError);
var ClientNotInitializedError = /*#__PURE__*/function (_SdkError26) {
  _inheritsLoose(ClientNotInitializedError, _SdkError26);
  function ClientNotInitializedError(client, cause) {
    return _SdkError26.call(this, client + " client is not initialized", cause) || this;
  }
  return ClientNotInitializedError;
}(SdkError);
var NoNodesAvailableError = /*#__PURE__*/function (_SdkError27) {
  _inheritsLoose(NoNodesAvailableError, _SdkError27);
  function NoNodesAvailableError(name, cause) {
    return _SdkError27.call(this, "No " + name + " nodes available", cause) || this;
  }
  return NoNodesAvailableError;
}(SdkError);
var PluginInstallationPreparationError = /*#__PURE__*/function (_SdkError28) {
  _inheritsLoose(PluginInstallationPreparationError, _SdkError28);
  function PluginInstallationPreparationError(cause) {
    return _SdkError28.call(this, "Failed to install plugin", cause) || this;
  }
  return PluginInstallationPreparationError;
}(SdkError);
var DataDecodingError = /*#__PURE__*/function (_SdkError29) {
  _inheritsLoose(DataDecodingError, _SdkError29);
  function DataDecodingError(message, cause) {
    return _SdkError29.call(this, "Cannot decode data: " + message, cause) || this;
  }
  return DataDecodingError;
}(SdkError);
var InvalidContractAddressError = /*#__PURE__*/function (_SdkError30) {
  _inheritsLoose(InvalidContractAddressError, _SdkError30);
  function InvalidContractAddressError(cause) {
    return _SdkError30.call(this, "Invalid contract address", cause) || this;
  }
  return InvalidContractAddressError;
}(SdkError);
var InvalidContractAbiError = /*#__PURE__*/function (_SdkError31) {
  _inheritsLoose(InvalidContractAbiError, _SdkError31);
  function InvalidContractAbiError(cause) {
    return _SdkError31.call(this, "Invalid contract ABI", cause) || this;
  }
  return InvalidContractAbiError;
}(SdkError);
var CannotEstimateGasError = /*#__PURE__*/function (_SdkError32) {
  _inheritsLoose(CannotEstimateGasError, _SdkError32);
  function CannotEstimateGasError(cause) {
    return _SdkError32.call(this, "Cannot estimate gas error", cause) || this;
  }
  return CannotEstimateGasError;
}(SdkError);
var InstallationNotFoundError = /*#__PURE__*/function (_SdkError33) {
  _inheritsLoose(InstallationNotFoundError, _SdkError33);
  function InstallationNotFoundError(cause) {
    return _SdkError33.call(this, "Installation not found", cause) || this;
  }
  return InstallationNotFoundError;
}(SdkError);
var PluginUninstallationPreparationError = /*#__PURE__*/function (_SdkError34) {
  _inheritsLoose(PluginUninstallationPreparationError, _SdkError34);
  function PluginUninstallationPreparationError(cause) {
    return _SdkError34.call(this, "plugin uninstallation error", cause) || this;
  }
  return PluginUninstallationPreparationError;
}(SdkError);
var MissingMetadataError = /*#__PURE__*/function (_SdkError35) {
  _inheritsLoose(MissingMetadataError, _SdkError35);
  function MissingMetadataError(cause) {
    return _SdkError35.call(this, "Missing metadata", cause) || this;
  }
  return MissingMetadataError;
}(SdkError);
var InvalidPrepareUninstallationAbiError = /*#__PURE__*/function (_SdkError36) {
  _inheritsLoose(InvalidPrepareUninstallationAbiError, _SdkError36);
  function InvalidPrepareUninstallationAbiError(cause) {
    return _SdkError36.call(this, "Invalid prepare uninstallation ABI", cause) || this;
  }
  return InvalidPrepareUninstallationAbiError;
}(SdkError);
var InvalidEnsError = /*#__PURE__*/function (_SdkError37) {
  _inheritsLoose(InvalidEnsError, _SdkError37);
  function InvalidEnsError(cause) {
    return _SdkError37.call(this, "Invalid subdomain format: use a-z, 0-9 and -", cause) || this;
  }
  return InvalidEnsError;
}(SdkError);
var DepositNativeTokenError = /*#__PURE__*/function (_SdkError38) {
  _inheritsLoose(DepositNativeTokenError, _SdkError38);
  function DepositNativeTokenError(cause) {
    return _SdkError38.call(this, "Please, use the token's transfer function directly", cause) || this;
  }
  return DepositNativeTokenError;
}(SdkError);

/**
 * This function emulates the Promise.allSettled()
 *
 * @param proms
 */
function allSettled(proms) {
  return Promise.all(proms.map(reflect));
}
function reflect(prom) {
  return prom.then(function (value) {
    return {
      value: value,
      status: "fulfilled"
    };
  })["catch"](function (reason) {
    return {
      reason: reason,
      status: "rejected"
    };
  });
}
function runAndRetry(_x) {
  return _runAndRetry.apply(this, arguments);
}
function _runAndRetry() {
  _runAndRetry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var func, onFail, shouldRetry, lastErr, result;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          func = _ref.func, onFail = _ref.onFail, shouldRetry = _ref.shouldRetry;
        case 1:
          _context.prev = 1;
          _context.next = 4;
          return func();
        case 4:
          result = _context.sent;
          return _context.abrupt("return", result);
        case 8:
          _context.prev = 8;
          _context.t0 = _context["catch"](1);
          lastErr = _context.t0;
          if (typeof onFail === "function") {
            onFail(_context.t0);
          }
        case 12:
          if (shouldRetry()) {
            _context.next = 1;
            break;
          }
        case 13:
          throw lastErr;
        case 14:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[1, 8]]);
  }));
  return _runAndRetry.apply(this, arguments);
}

var MultiUri = /*#__PURE__*/function () {
  function MultiUri(multiUri) {
    this.items = [];
    if (!multiUri) throw new Error("The multi URI is empty");
    this.items = multiUri.split(",");
  }
  _createClass(MultiUri, [{
    key: "ipfsCid",
    get: function get() {
      for (var _iterator = _createForOfIteratorHelperLoose(this.items), _step; !(_step = _iterator()).done;) {
        var item = _step.value;
        if (IPFS_CID_REGEX.test(item)) return item;else if (item.startsWith("ipfs://")) {
          item = item.substring(7);
        }
        var idx = item.indexOf("/");
        var cid = idx < 0 ? item : item.substring(0, idx);
        if (!IPFS_CID_REGEX.test(cid)) continue;
        return cid;
      }
      return null;
    }
  }, {
    key: "ipfs",
    get: function get() {
      for (var _iterator2 = _createForOfIteratorHelperLoose(this.items), _step2; !(_step2 = _iterator2()).done;) {
        var item = _step2.value;
        if (IPFS_CID_REGEX.test(item)) return {
          cid: item,
          path: ""
        };else if (item.startsWith("ipfs://")) {
          item = item.substring(7);
        }
        var pathIdx = item.indexOf("/");
        var cid = item;
        if (pathIdx < 0) {
          if (!IPFS_CID_REGEX.test(cid)) continue;
          return {
            cid: cid,
            path: ""
          };
        }
        cid = item.substring(0, pathIdx);
        if (!IPFS_CID_REGEX.test(cid)) continue;
        var searchIdx = item.indexOf("?");
        if (searchIdx < 0) searchIdx = item.indexOf("#");
        if (searchIdx < 0) {
          return {
            cid: cid,
            path: item.substring(pathIdx)
          };
        }
        return {
          cid: cid,
          path: item.substring(pathIdx, searchIdx)
        };
      }
      return null;
    }
  }, {
    key: "http",
    get: function get() {
      return this.items.filter(function (item) {
        return item.startsWith("http://") || item.startsWith("https://");
      });
    }
  }]);
  return MultiUri;
}();
var IPFS_CID_REGEX = /^Qm([1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})$/;
/** Attempts to parse the given string as a URL and returns the IPFS CiD contained in it.
 * Alternatively it tries to use the raw value after validating it.
 */
function resolveIpfsCid(data) {
  var uri = new MultiUri(data);
  var cid = uri.ipfsCid;
  if (!cid) {
    throw new InvalidCidError();
  }
  return cid;
}

/**
 * @param func The promise-returning function to invoke
 * @param timeout Timeout (in seconds) to wait before failing
 * @param timeoutMessage (optional) Message to use when throwing a timeout error
 */
function promiseFuncWithTimeout(func, timeout, timeoutMessage) {
  if (typeof func !== "function") throw new Error("Invalid function");else if (isNaN(timeout) || timeout < 0) throw new Error("Invalid timeout");
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      return reject(new TimeoutError(timeoutMessage || "Time out"));
    }, timeout);
    return func().then(function (result) {
      return resolve(result);
    })["catch"](function (err) {
      return reject(err);
    });
  });
}
/**
 * @param prom The promise to track
 * @param timeout Timeout (in milliseconds) to wait before failing
 * @param timeoutMessage (optional) Message to use when throwing a timeout error. By default: `"Time out"`
 */
function promiseWithTimeout(prom, timeout, timeoutMessage) {
  if (!prom || typeof prom.then !== "function" || typeof prom["catch"] !== "function") {
    throw new Error("Invalid promise");
  } else if (isNaN(timeout) || timeout < 0) throw new Error("Invalid timeout");
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      return reject(new TimeoutError(timeoutMessage || "Time out"));
    }, timeout);
    return prom.then(function (result) {
      return resolve(result);
    })["catch"](function (err) {
      return reject(err);
    });
  });
}

exports.AmountMismatchError = AmountMismatchError;
exports.CannotEstimateGasError = CannotEstimateGasError;
exports.ClientNotInitializedError = ClientNotInitializedError;
exports.DataDecodingError = DataDecodingError;
exports.DepositNativeTokenError = DepositNativeTokenError;
exports.FailedDepositError = FailedDepositError;
exports.GraphQLError = GraphQLError;
exports.InstallationNotFoundError = InstallationNotFoundError;
exports.InvalidAddressError = InvalidAddressError;
exports.InvalidAddressOrEnsError = InvalidAddressOrEnsError;
exports.InvalidCidError = InvalidCidError;
exports.InvalidContractAbiError = InvalidContractAbiError;
exports.InvalidContractAddressError = InvalidContractAddressError;
exports.InvalidEnsError = InvalidEnsError;
exports.InvalidPrecisionError = InvalidPrecisionError;
exports.InvalidPrepareUninstallationAbiError = InvalidPrepareUninstallationAbiError;
exports.InvalidProposalIdError = InvalidProposalIdError;
exports.InvalidVotingModeError = InvalidVotingModeError;
exports.IpfsError = IpfsError;
exports.IpfsFetchError = IpfsFetchError;
exports.IpfsPinError = IpfsPinError;
exports.MissingExecPermissionError = MissingExecPermissionError;
exports.MissingMetadataError = MissingMetadataError;
exports.MultiUri = MultiUri;
exports.NoDaoFactory = NoDaoFactory;
exports.NoDaoRegistry = NoDaoRegistry;
exports.NoNodesAvailableError = NoNodesAvailableError;
exports.NoPluginRepoRegistry = NoPluginRepoRegistry;
exports.NoProviderError = NoProviderError;
exports.NoSignerError = NoSignerError;
exports.NoTokenAddress = NoTokenAddress;
exports.PluginInstallationPreparationError = PluginInstallationPreparationError;
exports.PluginUninstallationPreparationError = PluginUninstallationPreparationError;
exports.ProposalCreationError = ProposalCreationError;
exports.TimeoutError = TimeoutError;
exports.UnexpectedActionError = UnexpectedActionError;
exports.UnsupportedNetworkError = UnsupportedNetworkError;
exports.UnsupportedProtocolError = UnsupportedProtocolError;
exports.UpdateAllowanceError = UpdateAllowanceError;
exports.allSettled = allSettled;
exports.bigIntToBuffer = bigIntToBuffer;
exports.bigIntToLeBuffer = bigIntToLeBuffer;
exports.bitmapToBoolArray = bitmapToBoolArray;
exports.boolArrayToBitmap = boolArrayToBitmap;
exports.bufferLeToBigInt = bufferLeToBigInt;
exports.bufferToBigInt = bufferToBigInt;
exports.bytesToHex = bytesToHex;
exports.decodeProposalId = decodeProposalId;
exports.decodeRatio = decodeRatio;
exports.encodeProposalId = encodeProposalId;
exports.encodeRatio = encodeRatio;
exports.ensure0x = ensure0x;
exports.getCompactProposalId = getCompactProposalId;
exports.getExtendedProposalId = getExtendedProposalId;
exports.hexToBytes = hexToBytes;
exports.isProposalId = isProposalId;
exports.promiseFuncWithTimeout = promiseFuncWithTimeout;
exports.promiseWithTimeout = promiseWithTimeout;
exports.resolveIpfsCid = resolveIpfsCid;
exports.runAndRetry = runAndRetry;
exports.strip0x = strip0x;
//# sourceMappingURL=sdk-common.cjs.development.js.map
