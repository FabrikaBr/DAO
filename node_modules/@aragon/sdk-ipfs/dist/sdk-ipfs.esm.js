import fetch from 'isomorphic-unfetch';

function _AsyncGenerator(gen) {
  var front, back;
  function resume(key, arg) {
    try {
      var result = gen[key](arg),
        value = result.value,
        overloaded = value instanceof _OverloadYield;
      Promise.resolve(overloaded ? value.v : value).then(function (arg) {
        if (overloaded) {
          var nextKey = "return" === key ? "return" : "next";
          if (!value.k || arg.done) return resume(nextKey, arg);
          arg = gen[nextKey](arg).value;
        }
        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }
  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: !0
        });
        break;
      case "throw":
        front.reject(value);
        break;
      default:
        front.resolve({
          value: value,
          done: !1
        });
    }
    (front = front.next) ? resume(front.key, front.arg) : back = null;
  }
  this._invoke = function (key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };
      back ? back = back.next = request : (front = back = request, resume(key, arg));
    });
  }, "function" != typeof gen.return && (this.return = void 0);
}
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () {
  return this;
}, _AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
}, _AsyncGenerator.prototype.throw = function (arg) {
  return this._invoke("throw", arg);
}, _AsyncGenerator.prototype.return = function (arg) {
  return this._invoke("return", arg);
};
function _OverloadYield(value, kind) {
  this.v = value, this.k = kind;
}
function _asyncGeneratorDelegate(inner) {
  var iter = {},
    waiting = !1;
  function pump(key, value) {
    return waiting = !0, value = new Promise(function (resolve) {
      resolve(inner[key](value));
    }), {
      done: !1,
      value: new _OverloadYield(value, 1)
    };
  }
  return iter["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function () {
    return this;
  }, iter.next = function (value) {
    return waiting ? (waiting = !1, value) : pump("next", value);
  }, "function" == typeof inner.throw && (iter.throw = function (value) {
    if (waiting) throw waiting = !1, value;
    return pump("throw", value);
  }), "function" == typeof inner.return && (iter.return = function (value) {
    return waiting ? (waiting = !1, value) : pump("return", value);
  }), iter;
}
function _asyncIterator(iterable) {
  var method,
    async,
    sync,
    retry = 2;
  for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {
    if (async && null != (method = iterable[async])) return method.call(iterable);
    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
    async = "@@asyncIterator", sync = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(s) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
    var done = r.done;
    return Promise.resolve(r.value).then(function (value) {
      return {
        value: value,
        done: done
      };
    });
  }
  return AsyncFromSyncIterator = function (s) {
    this.s = s, this.n = s.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function () {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    return: function (value) {
      var ret = this.s.return;
      return void 0 === ret ? Promise.resolve({
        value: value,
        done: !0
      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
    },
    throw: function (value) {
      var thr = this.s.return;
      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(s);
}
function _awaitAsyncGenerator(value) {
  return new _OverloadYield(value, 0);
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function _wrapAsyncGenerator(fn) {
  return function () {
    return new _AsyncGenerator(fn.apply(this, arguments));
  };
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}

var ClientError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(ClientError, _Error);
  function ClientError(res) {
    var _this;
    _this = _Error.call(this, res.statusText) || this;
    _this.name = "ClientError";
    _this.response = res;
    return _this;
  }
  return ClientError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
var InvalidResponseError = /*#__PURE__*/function (_ClientError) {
  _inheritsLoose(InvalidResponseError, _ClientError);
  function InvalidResponseError(res) {
    var _this2;
    _this2 = _ClientError.call(this, res) || this;
    _this2.message = "Invalid response";
    return _this2;
  }
  return InvalidResponseError;
}(ClientError);
var MissingBodyeError = /*#__PURE__*/function (_ClientError2) {
  _inheritsLoose(MissingBodyeError, _ClientError2);
  function MissingBodyeError(res) {
    var _this3;
    _this3 = _ClientError2.call(this, res) || this;
    _this3.message = "Missing response body";
    return _this3;
  }
  return MissingBodyeError;
}(ClientError);
var BodyParseError = /*#__PURE__*/function (_ClientError3) {
  _inheritsLoose(BodyParseError, _ClientError3);
  function BodyParseError(res) {
    var _this4;
    _this4 = _ClientError3.call(this, res) || this;
    _this4.message = "Error parsing body";
    return _this4;
  }
  return BodyParseError;
}(ClientError);

var Network;
(function (Network) {
  /**
   * Performs a request and returns a JSON object with the response
   */
  function request(_x5, _x6, _x7) {
    return _request.apply(this, arguments);
  }
  function _request() {
    _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(config, path, _ref) {
      var method, params, body, signal, url, headers, endpoint, _i2, _Object$entries2, _Object$entries2$_i, key, value, response;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            method = _ref.method, params = _ref.params, body = _ref.body, signal = _ref.signal;
            url = config.url, headers = config.headers;
            endpoint = new URL(path, url);
            for (_i2 = 0, _Object$entries2 = Object.entries(params || {}); _i2 < _Object$entries2.length; _i2++) {
              _Object$entries2$_i = _Object$entries2[_i2], key = _Object$entries2$_i[0], value = _Object$entries2$_i[1];
              if (value != null) {
                endpoint.searchParams.set(key, String(value));
              }
            }
            _context3.next = 6;
            return fetch(endpoint.href, {
              method: method || "GET",
              headers: headers,
              body: body,
              signal: signal
            });
          case 6:
            response = _context3.sent;
            if (response.ok) {
              _context3.next = 9;
              break;
            }
            throw new InvalidResponseError(response);
          case 9:
            return _context3.abrupt("return", response.json());
          case 10:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return _request.apply(this, arguments);
  }
  Network.request = request;
  function stream(_x, _x2, _x3) {
    return _stream.apply(this, arguments);
  }
  function _stream() {
    _stream = _wrapAsyncGenerator(function (_ref2, path, _ref3) {
      var url = _ref2.url,
        headers = _ref2.headers;
      var method = _ref3.method,
        params = _ref3.params,
        body = _ref3.body,
        signal = _ref3.signal;
      return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var endpoint, _i, _Object$entries, _Object$entries$_i, key, value, res;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              endpoint = new URL(path, url);
              for (_i = 0, _Object$entries = Object.entries(params || {}); _i < _Object$entries.length; _i++) {
                _Object$entries$_i = _Object$entries[_i], key = _Object$entries$_i[0], value = _Object$entries$_i[1];
                if (value != null) {
                  endpoint.searchParams.set(key, String(value));
                }
              }
              method = method || "GET";
              _context.next = 5;
              return _awaitAsyncGenerator(fetch(endpoint.href, {
                method: method,
                headers: headers,
                body: body,
                signal: signal
              }));
            case 5:
              res = _context.sent;
              if (res.ok) {
                _context.next = 8;
                break;
              }
              throw new InvalidResponseError(res);
            case 8:
              if (res.body) {
                _context.next = 10;
                break;
              }
              throw new MissingBodyeError(res);
            case 10:
              return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(streamedBytes(res.body))), "t0", 11);
            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee);
      })();
    });
    return _stream.apply(this, arguments);
  }
  Network.stream = stream;
  function streamedBytes(_x4) {
    return _streamedBytes.apply(this, arguments);
  }
  function _streamedBytes() {
    _streamedBytes = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(stream) {
      var error, reader, result;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            error = null;
            reader = stream.getReader();
            _context2.prev = 2;
          case 3:
            _context2.next = 6;
            return _awaitAsyncGenerator(reader.read());
          case 6:
            result = _context2.sent;
            if (!result.done) {
              _context2.next = 9;
              break;
            }
            return _context2.abrupt("break", 13);
          case 9:
            _context2.next = 11;
            return result.value;
          case 11:
            _context2.next = 3;
            break;
          case 13:
            _context2.next = 18;
            break;
          case 15:
            _context2.prev = 15;
            _context2.t0 = _context2["catch"](2);
            error = _context2.t0;
          case 18:
            _context2.prev = 18;
            reader.cancel();
            reader.releaseLock();
            return _context2.finish(18);
          case 22:
            if (!error) {
              _context2.next = 24;
              break;
            }
            throw error;
          case 24:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[2, 15, 18, 22]]);
    }));
    return _streamedBytes.apply(this, arguments);
  }
})(Network || (Network = {}));

var Helpers;
(function (Helpers) {
  function getName(file) {
    return file.name;
  }
  Helpers.getName = getName;
  function handleError(error) {
    var _error$response;
    if ((_error$response = error.response) != null && _error$response.ok) {
      return new BodyParseError(error.response);
    } else {
      return error;
    }
  }
  Helpers.handleError = handleError;
  function streamToUInt8Array(_x) {
    return _streamToUInt8Array.apply(this, arguments);
  }
  function _streamToUInt8Array() {
    _streamToUInt8Array = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(stream) {
      var chunks, byteCount, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk, mergedArray, lastIndex, _i, _chunks, _chunk;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            chunks = [];
            byteCount = 0;
            _iteratorAbruptCompletion = false;
            _didIteratorError = false;
            _context.prev = 4;
            _iterator = _asyncIterator(stream);
          case 6:
            _context.next = 8;
            return _iterator.next();
          case 8:
            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
              _context.next = 15;
              break;
            }
            chunk = _step.value;
            chunks.push(chunk);
            byteCount += chunk.length;
          case 12:
            _iteratorAbruptCompletion = false;
            _context.next = 6;
            break;
          case 15:
            _context.next = 21;
            break;
          case 17:
            _context.prev = 17;
            _context.t0 = _context["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context.t0;
          case 21:
            _context.prev = 21;
            _context.prev = 22;
            if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
              _context.next = 26;
              break;
            }
            _context.next = 26;
            return _iterator["return"]();
          case 26:
            _context.prev = 26;
            if (!_didIteratorError) {
              _context.next = 29;
              break;
            }
            throw _iteratorError;
          case 29:
            return _context.finish(26);
          case 30:
            return _context.finish(21);
          case 31:
            mergedArray = new Uint8Array(byteCount);
            lastIndex = 0;
            for (_i = 0, _chunks = chunks; _i < _chunks.length; _i++) {
              _chunk = _chunks[_i];
              mergedArray.set(_chunk, lastIndex);
              lastIndex += _chunk.length;
            }
            return _context.abrupt("return", mergedArray);
          case 35:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[4, 17, 21, 31], [22,, 26, 30]]);
    }));
    return _streamToUInt8Array.apply(this, arguments);
  }
  Helpers.streamToUInt8Array = streamToUInt8Array;
  function toVersionResponse(data) {
    var version = data.Version,
      commit = data.Commit,
      repo = data.Repo,
      system = data.System,
      golang = data.Golang;
    return {
      version: version,
      commit: commit,
      repo: repo,
      system: system,
      golang: golang
    };
  }
  Helpers.toVersionResponse = toVersionResponse;
  function toNodeInfoResponse(data) {
    var id = data.ID,
      addresses = data.Addresses,
      agentVersion = data.AgentVersion,
      protocolVersion = data.ProtocolVersion,
      protocols = data.Protocols,
      publicKey = data.PublicKey;
    return {
      id: id,
      addresses: addresses,
      agentVersion: agentVersion,
      protocolVersion: protocolVersion,
      protocols: protocols,
      publicKey: publicKey
    };
  }
  Helpers.toNodeInfoResponse = toNodeInfoResponse;
  function toAddResponse(data) {
    var bytes = data.Bytes,
      hash = data.Hash,
      name = data.Name,
      size = data.Size;
    return {
      bytes: bytes,
      hash: hash,
      name: name,
      size: size
    };
  }
  Helpers.toAddResponse = toAddResponse;
  function toPinResponse(data) {
    var pins = data.Pins,
      progress = data.Progress;
    return {
      pins: pins,
      progress: progress
    };
  }
  Helpers.toPinResponse = toPinResponse;
  function getVersionParams(options) {
    if (options === void 0) {
      options = {};
    }
    return encodeParams({
      number: options.number,
      commit: options.commit,
      all: options.all
    });
  }
  Helpers.getVersionParams = getVersionParams;
  function getNodeInfoParams(options) {
    if (options === void 0) {
      options = {};
    }
    return encodeParams({
      arg: options.arg,
      format: options.format,
      "peerid-base": options.peeridBase
    });
  }
  Helpers.getNodeInfoParams = getNodeInfoParams;
  function getAddParams(options) {
    if (options === void 0) {
      options = {};
    }
    return encodeParams({
      quiet: options.quiet,
      quieter: options.quieter,
      silent: options.silent,
      progress: options.progress,
      trickle: options.trickle,
      "only-hash": options.onlyHash,
      "wrap-with-directory": options.wrapWithDirectory,
      chunker: options.chunker,
      pin: options.pin,
      "raw-leaves": options.rawLeaves,
      nocopy: options.noCopy,
      fscache: options.fsCache,
      "cid-version": options.cidVersion,
      hash: options.hash,
      inline: options.inline,
      "inline-limit": options.inlineLimit
    });
  }
  Helpers.getAddParams = getAddParams;
  function getCatParams(options) {
    if (options === void 0) {
      options = {};
    }
    return encodeParams({
      offset: options.offset,
      length: options.length,
      progress: options.progress
    });
  }
  Helpers.getCatParams = getCatParams;
  function getPinOptions(options) {
    if (options === void 0) {
      options = {};
    }
    return encodeParams({
      recursive: options.recursive,
      progress: options.progress
    });
  }
  Helpers.getPinOptions = getPinOptions;
  function getUnpinOptions(options) {
    if (options === void 0) {
      options = {};
    }
    return encodeParams({
      recursive: options.recursive
    });
  }
  Helpers.getUnpinOptions = getUnpinOptions;
  function encodeParams(options) {
    // @ts-ignore
    return Object.fromEntries(Object.entries(options).filter(function (_ref) {
      var v = _ref[1];
      return v != null;
    }));
  }
})(Helpers || (Helpers = {}));

var API;
(function (API) {
  /** Gets cluster version */
  function version(cluster, options) {
    if (options === void 0) {
      options = {};
    }
    return Network.request(cluster, "version", {
      method: "POST",
      params: Helpers.getVersionParams(options),
      signal: options.signal
    }).then(function (response) {
      return Helpers.toVersionResponse(response);
    })["catch"](function (e) {
      throw Helpers.handleError(e);
    });
  }
  API.version = version;
  /** Gets the cluster node information */
  function nodeInfo(cluster, options) {
    if (options === void 0) {
      options = {};
    }
    return Network.request(cluster, "id", {
      method: "POST",
      params: Helpers.getNodeInfoParams(options),
      signal: options.signal
    }).then(function (response) {
      return Helpers.toNodeInfoResponse(response);
    })["catch"](function (e) {
      throw Helpers.handleError(e);
    });
  }
  API.nodeInfo = nodeInfo;
  /** Upload a file to the cluster and pin it */
  function add(cluster, file, options) {
    if (options === void 0) {
      options = {};
    }
    if (!(file instanceof File) && !(file instanceof Blob) && !(file instanceof Uint8Array) && typeof file !== "string") {
      throw new Error("Invalid file");
    }
    var body = new FormData();
    if (typeof file === "string") {
      body.append("path", file);
    } else if (file instanceof Uint8Array) {
      body.append("path", new Blob([file]));
    } else {
      body.append("path", file, getName(file) || "file");
    }
    return Network.request(cluster, "add", {
      params: Helpers.getAddParams(options),
      method: "POST",
      body: body,
      signal: options.signal
    }).then(function (response) {
      return Helpers.toAddResponse(response);
    })["catch"](function (e) {
      throw Helpers.handleError(e);
    });
  }
  API.add = add;
  /** Fetches the data behind the given path or CiD and returns it as bytes */
  function cat(_x, _x2, _x3) {
    return _cat.apply(this, arguments);
  }
  function _cat() {
    _cat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(cluster, path, options) {
      var stream;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (options === void 0) {
              options = {};
            }
            if (path) {
              _context.next = 3;
              break;
            }
            throw new Error("Invalid CID");
          case 3:
            stream = Network.stream(cluster, "cat", {
              method: "POST",
              params: _extends({}, Helpers.getCatParams(options), {
                arg: path
              }),
              signal: options.signal
            });
            return _context.abrupt("return", Helpers.streamToUInt8Array(stream));
          case 5:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _cat.apply(this, arguments);
  }
  API.cat = cat;
  /** Pins the given path or CiD or IPFS/IPNS path to the cluster */
  function pin(cluster, path, options) {
    if (options === void 0) {
      options = {};
    }
    return Network.request(cluster, "pin/add", {
      params: _extends({}, Helpers.getPinOptions(options), {
        arg: path
      }),
      method: "POST",
      signal: options.signal
    }).then(function (response) {
      return Helpers.toPinResponse(response);
    });
  }
  API.pin = pin;
  /** Unpins the given path or CiD or IPFS/IPNS path from the cluster */
  function unpin(cluster, path, options) {
    if (options === void 0) {
      options = {};
    }
    return Network.request(cluster, "pin/rm", {
      params: _extends({}, Helpers.getUnpinOptions(options), {
        arg: path
      }),
      method: "POST",
      signal: options.signal
    }).then(function (response) {
      return Helpers.toPinResponse(response);
    });
  }
  API.unpin = unpin;
})(API || (API = {}));
var getName = function getName(file) {
  return file.name;
};

var Client = /*#__PURE__*/function () {
  /** Create a new instance of the IPFS cluster client */
  function Client(url, headers) {
    var newUrl = typeof url === "string" ? new URL(url) : url;
    if (!newUrl.pathname.endsWith("/")) {
      newUrl.pathname += "/";
    }
    this.url = newUrl;
    this.headers = headers || {};
  }
  /**
   * Get Cluster version.
   * @param {API.RequestOptions} [options]
   */
  var _proto = Client.prototype;
  _proto.version = function version(options) {
    return API.version(this, options);
  }
  /**
   * Get Cluster peer information.
   */;
  _proto.nodeInfo = function nodeInfo(options) {
    return API.nodeInfo(this, options);
  }
  /**
   * Imports a file to the cluster. First argument must be a `File` or `Blob`.
   * Note: by default this module uses v1 CIDs and raw leaves enabled.
   */;
  _proto.add = function add(file, options) {
    return API.add(this, file, options);
  }
  /** Fetches the contents behind the cid and returns them as an Uint8Array */;
  _proto.cat = function cat(path, options) {
    return API.cat(this, path, options);
  }
  /**
   * Tracks a path with the given replication factor and a name for
   * human-friendliness.
   */;
  _proto.pin = function pin(path, options) {
    return API.pin(this, path, options);
  }
  /**
   * Untracks a path on the cluster.
   */;
  _proto.unpin = function unpin(path, options) {
    return API.unpin(this, path, options);
  };
  return Client;
}();

export { BodyParseError, Client, ClientError, InvalidResponseError, MissingBodyeError };
//# sourceMappingURL=sdk-ipfs.esm.js.map
