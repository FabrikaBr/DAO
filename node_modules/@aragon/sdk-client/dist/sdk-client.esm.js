import { activeContractsList, MajorityVotingBase__factory, DAO__factory, PluginSetupProcessor__factory, DAORegistry__factory, PluginRepo__factory, DAOFactory__factory, AddresslistVoting__factory, IERC20MintableUpgradeable__factory, TokenVoting__factory, GovernanceWrappedERC20__factory, GovernanceERC20__factory, Multisig__factory } from '@aragon/osx-ethers';
import { NoProviderError, NoNodesAvailableError, NoSignerError, UnsupportedNetworkError, InvalidAddressError, InvalidContractAbiError, CannotEstimateGasError, NoDaoFactory, ClientNotInitializedError, runAndRetry, IpfsError, DataDecodingError, GraphQLError, UnsupportedProtocolError, InvalidVotingModeError, bytesToHex, decodeRatio, encodeRatio, hexToBytes, AmountMismatchError, FailedDepositError, UpdateAllowanceError, PluginUninstallationPreparationError, InstallationNotFoundError, MissingExecPermissionError, InvalidEnsError, IpfsPinError, InvalidCidError, resolveIpfsCid, InvalidAddressOrEnsError, DepositNativeTokenError, getCompactProposalId, encodeProposalId, ProposalCreationError, boolArrayToBitmap, decodeProposalId, PluginInstallationPreparationError, getExtendedProposalId, isProposalId, InvalidProposalIdError } from '@aragon/sdk-common';
import { Interface, defaultAbiCoder } from '@ethersproject/abi';
import { BigNumber } from '@ethersproject/bignumber';
import { AddressZero } from '@ethersproject/constants';
import { Contract } from '@ethersproject/contracts';
import { gql, ClientError as ClientError$1, GraphQLClient } from 'graphql-request';
import { isAddress } from '@ethersproject/address';
import { ClientError, Client as Client$1 } from '@aragon/sdk-ipfs';
import { getNetwork, JsonRpcProvider } from '@ethersproject/providers';
import { id } from '@ethersproject/hash';
import { keccak256 } from '@ethersproject/keccak256';
import { toUtf8Bytes, toUtf8String } from '@ethersproject/strings';

function _AsyncGenerator(gen) {
  var front, back;
  function resume(key, arg) {
    try {
      var result = gen[key](arg),
        value = result.value,
        overloaded = value instanceof _OverloadYield;
      Promise.resolve(overloaded ? value.v : value).then(function (arg) {
        if (overloaded) {
          var nextKey = "return" === key ? "return" : "next";
          if (!value.k || arg.done) return resume(nextKey, arg);
          arg = gen[nextKey](arg).value;
        }
        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }
  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: !0
        });
        break;
      case "throw":
        front.reject(value);
        break;
      default:
        front.resolve({
          value: value,
          done: !1
        });
    }
    (front = front.next) ? resume(front.key, front.arg) : back = null;
  }
  this._invoke = function (key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };
      back ? back = back.next = request : (front = back = request, resume(key, arg));
    });
  }, "function" != typeof gen.return && (this.return = void 0);
}
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () {
  return this;
}, _AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
}, _AsyncGenerator.prototype.throw = function (arg) {
  return this._invoke("throw", arg);
}, _AsyncGenerator.prototype.return = function (arg) {
  return this._invoke("return", arg);
};
function _OverloadYield(value, kind) {
  this.v = value, this.k = kind;
}
function _asyncGeneratorDelegate(inner) {
  var iter = {},
    waiting = !1;
  function pump(key, value) {
    return waiting = !0, value = new Promise(function (resolve) {
      resolve(inner[key](value));
    }), {
      done: !1,
      value: new _OverloadYield(value, 1)
    };
  }
  return iter["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function () {
    return this;
  }, iter.next = function (value) {
    return waiting ? (waiting = !1, value) : pump("next", value);
  }, "function" == typeof inner.throw && (iter.throw = function (value) {
    if (waiting) throw waiting = !1, value;
    return pump("throw", value);
  }), "function" == typeof inner.return && (iter.return = function (value) {
    return waiting ? (waiting = !1, value) : pump("return", value);
  }), iter;
}
function _asyncIterator(iterable) {
  var method,
    async,
    sync,
    retry = 2;
  for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {
    if (async && null != (method = iterable[async])) return method.call(iterable);
    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
    async = "@@asyncIterator", sync = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(s) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
    var done = r.done;
    return Promise.resolve(r.value).then(function (value) {
      return {
        value: value,
        done: done
      };
    });
  }
  return AsyncFromSyncIterator = function (s) {
    this.s = s, this.n = s.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function () {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    return: function (value) {
      var ret = this.s.return;
      return void 0 === ret ? Promise.resolve({
        value: value,
        done: !0
      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
    },
    throw: function (value) {
      var thr = this.s.return;
      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(s);
}
function _awaitAsyncGenerator(value) {
  return new _OverloadYield(value, 0);
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function _wrapAsyncGenerator(fn) {
  return function () {
    return new _AsyncGenerator(fn.apply(this, arguments));
  };
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  strings.raw = raw;
  return strings;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var erc20ContractAbi = [{
  name: "Transfer",
  inputs: [{
    type: "address",
    name: "sender",
    indexed: true
  }, {
    type: "address",
    name: "receiver",
    indexed: true
  }, {
    type: "uint256",
    name: "value",
    indexed: false
  }],
  anonymous: false,
  type: "event"
}, {
  name: "Approval",
  inputs: [{
    type: "address",
    name: "owner",
    indexed: true
  }, {
    type: "address",
    name: "spender",
    indexed: true
  }, {
    type: "uint256",
    name: "value",
    indexed: false
  }],
  anonymous: false,
  type: "event"
}, {
  name: "transfer",
  outputs: [{
    type: "bool",
    name: ""
  }],
  inputs: [{
    type: "address",
    name: "_to"
  }, {
    type: "uint256",
    name: "_value"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  name: "approve",
  outputs: [{
    type: "bool",
    name: ""
  }],
  inputs: [{
    type: "address",
    name: "_spender"
  }, {
    type: "uint256",
    name: "_value"
  }],
  stateMutability: "nonpayable",
  type: "function"
}, {
  name: "symbol",
  outputs: [{
    type: "string",
    name: ""
  }],
  inputs: [],
  stateMutability: "view",
  type: "function"
}, {
  name: "decimals",
  outputs: [{
    type: "uint256",
    name: ""
  }],
  inputs: [],
  stateMutability: "view",
  type: "function"
}, {
  name: "balanceOf",
  outputs: [{
    type: "uint256",
    name: ""
  }],
  inputs: [{
    type: "address",
    name: "arg0"
  }],
  stateMutability: "view",
  type: "function"
}, {
  name: "allowance",
  outputs: [{
    type: "uint256",
    name: ""
  }],
  inputs: [{
    type: "address",
    name: "arg0"
  }, {
    type: "address",
    name: "arg1"
  }],
  stateMutability: "view",
  type: "function"
}, {
  name: "totalSupply",
  outputs: [{
    type: "uint256",
    name: ""
  }],
  inputs: [],
  stateMutability: "view",
  type: "function"
}];

var _templateObject, _templateObject2;
var QueryDao = /*#__PURE__*/gql(_templateObject || (_templateObject = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  query Dao($address: ID!) {\n    dao(id: $address){\n      id\n      subdomain\n      metadata\n      createdAt\n      plugins{\n        appliedPreparation {\n          pluginAddress\n        }\n        appliedPluginRepo {\n          subdomain\n        }\n        appliedVersion{\n          build\n          release {\n            release\n          }\n        }\n      }\n    }\n  }\n"])));
var QueryDaos = /*#__PURE__*/gql(_templateObject2 || (_templateObject2 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  query Daos ($limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: Dao_orderBy!) {\n    daos(first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy){\n      id\n      subdomain\n      metadata\n      plugins{\n        appliedPreparation {\n          pluginAddress\n        }\n        appliedPluginRepo {\n          subdomain\n        }\n        appliedVersion{\n          build\n          release {\n            release\n          }\n        }\n      }\n    }\n  }\n"])));

var _templateObject$1;
var QueryTokenBalances = /*#__PURE__*/gql(_templateObject$1 || (_templateObject$1 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenBalances($where: TokenBalance_filter!, $limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: TokenBalance_orderBy!) {\n  tokenBalances (where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy) {\n    lastUpdated\n    __typename\n    ... on ERC20Balance {\n      balance\n      token {\n        name\n        decimals\n        symbol\n        id\n      }\n    }\n    ... on ERC721Balance {\n      token {\n        name\n        symbol\n        id\n      }\n    }\n    ... on NativeBalance {\n      balance\n    }\n  }\n}\n"])));

var _templateObject$2;
var QueryTokenTransfers = /*#__PURE__*/gql(_templateObject$2 || (_templateObject$2 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenTransfers($where: TokenTransfer_filter!, $limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: TokenTransfer_orderBy!) {\n  tokenTransfers (where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy) {\n    from\n    to\n    type\n    createdAt\n    txHash\n    proposal{\n      id\n    }\n    __typename\n    ... on ERC20Transfer {\n      amount\n      token {\n        id\n        name\n        symbol\n        decimals\n      }\n    }\n    ... on ERC721Transfer {\n      token{\n      \tid\n        name\n        symbol\n      }\n      \n    }\n    ... on NativeTransfer {\n      amount\n    }\n  }\n}\n"])));

var _templateObject$3, _templateObject2$1, _templateObject3;
var QueryPlugins = /*#__PURE__*/gql(_templateObject$3 || (_templateObject$3 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery Plugins($where: PluginRepo_filter!, $limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: PluginRepo_orderBy!) {\n  pluginRepos(where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy){\n    id\n    subdomain\n    releases{\n      release\n      metadata\n      builds{\n        build\n      }\n    }\n  }\n}\n"])));
var QueryPlugin = /*#__PURE__*/gql(_templateObject2$1 || (_templateObject2$1 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery Plugin($id: ID!) {\n  pluginRepo(id:$id){\n    subdomain\n    releases(orderBy: release, orderDirection: desc, first: 1){\n      release\n      metadata\n      builds(orderBy: build, orderDirection: desc, first: 1){\n        build\n        metadata\n      }\n    }\n  }\n}\n"])));
var QueryIPlugin = /*#__PURE__*/gql(_templateObject3 || (_templateObject3 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery IPlugin($address: ID!, $where: IPlugin_filter!) {\n\tiplugin(id:$address, where:$where){\n    installations(where:{state: Installed}) {\n      appliedPreparation{\n        helpers\n        pluginRepo {\n          id\n        }\n      }\n     \tappliedVersion {\n        metadata\n        build\n        release{\n          release\n        }\n      }\n    }   \n  }\n}\n"])));

var DaoCreationSteps;
(function (DaoCreationSteps) {
  DaoCreationSteps["CREATING"] = "creating";
  DaoCreationSteps["DONE"] = "done";
})(DaoCreationSteps || (DaoCreationSteps = {}));
var DaoSortBy;
(function (DaoSortBy) {
  DaoSortBy["CREATED_AT"] = "createdAt";
  DaoSortBy["SUBDOMAIN"] = "subdomain";
  // POPULARITY = "totalProposals", // currently defined as number of proposals
})(DaoSortBy || (DaoSortBy = {}));
var PluginSortBy;
(function (PluginSortBy) {
  PluginSortBy["SUBDOMAIN"] = "subdomain";
})(PluginSortBy || (PluginSortBy = {}));
var DaoDepositSteps;
(function (DaoDepositSteps) {
  DaoDepositSteps["CHECKED_ALLOWANCE"] = "checkedAllowance";
  DaoDepositSteps["DEPOSITING"] = "depositing";
  DaoDepositSteps["DONE"] = "done";
})(DaoDepositSteps || (DaoDepositSteps = {}));
var AssetBalanceSortBy;
(function (AssetBalanceSortBy) {
  AssetBalanceSortBy["LAST_UPDATED"] = "lastUpdated";
})(AssetBalanceSortBy || (AssetBalanceSortBy = {}));
var TransferType;
(function (TransferType) {
  TransferType["DEPOSIT"] = "deposit";
  TransferType["WITHDRAW"] = "withdraw";
})(TransferType || (TransferType = {}));
var TransferSortBy;
(function (TransferSortBy) {
  TransferSortBy["CREATED_AT"] = "createdAt";
})(TransferSortBy || (TransferSortBy = {}));
var SetAllowanceSteps;
(function (SetAllowanceSteps) {
  SetAllowanceSteps["SETTING_ALLOWANCE"] = "settingAllowance";
  SetAllowanceSteps["ALLOWANCE_SET"] = "allowanceSet";
})(SetAllowanceSteps || (SetAllowanceSteps = {}));
var PrepareUninstallationSteps;
(function (PrepareUninstallationSteps) {
  PrepareUninstallationSteps["PREPARING"] = "preparing";
  PrepareUninstallationSteps["DONE"] = "done";
})(PrepareUninstallationSteps || (PrepareUninstallationSteps = {}));

var SubgraphTransferType;
(function (SubgraphTransferType) {
  SubgraphTransferType["DEPOSIT"] = "Deposit";
  SubgraphTransferType["WITHDRAW"] = "Withdraw";
})(SubgraphTransferType || (SubgraphTransferType = {}));
var SubgraphTransferTypeMap = /*#__PURE__*/new Map([[TransferType.DEPOSIT, SubgraphTransferType.DEPOSIT], [TransferType.WITHDRAW, SubgraphTransferType.WITHDRAW]]);

/**
 * Contains the states of a proposal. Note that on chain
 * proposals cannot be in draft state
 */
var ProposalStatus;
(function (ProposalStatus) {
  ProposalStatus["ACTIVE"] = "Active";
  ProposalStatus["PENDING"] = "Pending";
  ProposalStatus["SUCCEEDED"] = "Succeeded";
  ProposalStatus["EXECUTED"] = "Executed";
  ProposalStatus["DEFEATED"] = "Defeated";
})(ProposalStatus || (ProposalStatus = {}));
var VoteValues;
(function (VoteValues) {
  // NONE = 0,
  VoteValues[VoteValues["ABSTAIN"] = 1] = "ABSTAIN";
  VoteValues[VoteValues["YES"] = 2] = "YES";
  VoteValues[VoteValues["NO"] = 3] = "NO";
})(VoteValues || (VoteValues = {}));
var VotingMode;
(function (VotingMode) {
  VotingMode["STANDARD"] = "Standard";
  VotingMode["EARLY_EXECUTION"] = "EarlyExecution";
  VotingMode["VOTE_REPLACEMENT"] = "VoteReplacement";
})(VotingMode || (VotingMode = {}));
var SubgraphVoteValues;
(function (SubgraphVoteValues) {
  SubgraphVoteValues["YES"] = "Yes";
  SubgraphVoteValues["NO"] = "No";
  SubgraphVoteValues["ABSTAIN"] = "Abstain";
})(SubgraphVoteValues || (SubgraphVoteValues = {}));
var SubgraphVoteValuesMap = /*#__PURE__*/new Map([[SubgraphVoteValues.YES, VoteValues.YES], [SubgraphVoteValues.NO, VoteValues.NO], [SubgraphVoteValues.ABSTAIN, VoteValues.ABSTAIN]]);
var ProposalSortBy;
(function (ProposalSortBy) {
  ProposalSortBy["CREATED_AT"] = "createdAt";
  // POPULARITY = "popularity",
  // VOTES = "votes",
})(ProposalSortBy || (ProposalSortBy = {}));
// STEPS
// PROPOSAL CREATION
var ProposalCreationSteps;
(function (ProposalCreationSteps) {
  ProposalCreationSteps["CREATING"] = "creating";
  ProposalCreationSteps["DONE"] = "done";
})(ProposalCreationSteps || (ProposalCreationSteps = {}));
// PROPOSAL VOTING
var VoteProposalStep;
(function (VoteProposalStep) {
  VoteProposalStep["VOTING"] = "voting";
  VoteProposalStep["DONE"] = "done";
})(VoteProposalStep || (VoteProposalStep = {}));
// PROPOSAL EXECUTION
var ExecuteProposalStep;
(function (ExecuteProposalStep) {
  ExecuteProposalStep["EXECUTING"] = "executing";
  ExecuteProposalStep["DONE"] = "done";
})(ExecuteProposalStep || (ExecuteProposalStep = {}));
var PrepareInstallationStep;
(function (PrepareInstallationStep) {
  PrepareInstallationStep["PREPARING"] = "preparing";
  PrepareInstallationStep["DONE"] = "done";
})(PrepareInstallationStep || (PrepareInstallationStep = {}));
var PermissionOperationType;
(function (PermissionOperationType) {
  PermissionOperationType[PermissionOperationType["GRANT"] = 0] = "GRANT";
  PermissionOperationType[PermissionOperationType["REVOKE"] = 1] = "REVOKE";
  PermissionOperationType[PermissionOperationType["GRANT_WITH_CONDITION"] = 2] = "GRANT_WITH_CONDITION";
})(PermissionOperationType || (PermissionOperationType = {}));

var SupportedNetwork;
(function (SupportedNetwork) {
  SupportedNetwork["MAINNET"] = "homestead";
  SupportedNetwork["GOERLI"] = "goerli";
  SupportedNetwork["POLYGON"] = "matic";
  SupportedNetwork["MUMBAI"] = "maticmum";
})(SupportedNetwork || (SupportedNetwork = {}));
var SupportedNetworksArray = /*#__PURE__*/Object.values(SupportedNetwork);
// This file contains common types, interfaces, and enumerations
var DaoRole;
(function (DaoRole) {
  DaoRole["UPGRADE_ROLE"] = "UPGRADE_ROLE";
  DaoRole["DAO_CONFIG_ROLE"] = "DAO_CONFIG_ROLE";
  DaoRole["EXEC_ROLE"] = "EXEC_ROLE";
  DaoRole["WITHDRAW_ROLE"] = "WITHDRAW_ROLE";
  DaoRole["SET_SIGNATURE_VALIDATOR_ROLE"] = "SET_SIGNATURE_VALIDATOR_ROLE";
})(DaoRole || (DaoRole = {}));
var SortDirection;
(function (SortDirection) {
  SortDirection["ASC"] = "asc";
  SortDirection["DESC"] = "desc";
})(SortDirection || (SortDirection = {}));
var TokenType;
(function (TokenType) {
  TokenType["NATIVE"] = "native";
  TokenType["ERC20"] = "erc20";
  TokenType["ERC721"] = "erc721";
})(TokenType || (TokenType = {}));

var Web3Module = /*#__PURE__*/function () {
  function Web3Module(context) {
    this.providerIdx = -1;
    this.context = context;
    this.providerIdx = Math.floor(Math.random() * context.web3Providers.length);
  }
  /** Starts using the next available Web3 provider */
  var _proto = Web3Module.prototype;
  _proto.shiftProvider = function shiftProvider() {
    if (!this.context.web3Providers.length) {
      throw new NoProviderError();
    } else if (this.context.web3Providers.length <= 1) {
      throw new NoNodesAvailableError("web3");
    }
    this.providerIdx = (this.providerIdx + 1) % this.context.web3Providers.length;
  }
  /** Retrieves the current signer */;
  _proto.getSigner = function getSigner() {
    if (!this.context.signer) {
      throw new NoSignerError();
    }
    return this.context.signer;
  }
  /** Returns the currently active network provider */;
  _proto.getProvider = function getProvider() {
    if (!this.context.web3Providers[this.providerIdx]) {
      throw new NoProviderError();
    }
    return this.context.web3Providers[this.providerIdx];
  }
  /** Returns the currently active network */;
  _proto.getNetworkName = function getNetworkName() {
    var networkName = this.context.network.name;
    if (!SupportedNetworksArray.includes(networkName)) {
      throw new UnsupportedNetworkError(networkName);
    }
    return networkName;
  }
  /** Returns a signer connected to the current network provider */;
  _proto.getConnectedSigner = function getConnectedSigner() {
    var signer = this.getSigner();
    if (!signer.provider) {
      var provider = this.getProvider();
      signer = signer.connect(provider);
    }
    return signer;
  }
  /** Returns whether the current provider is functional or not */;
  _proto.isUp = function isUp() {
    var provider = this.getProvider();
    return provider.getNetwork().then(function () {
      return true;
    })["catch"](function () {
      return false;
    });
  };
  _proto.ensureOnline = /*#__PURE__*/function () {
    var _ensureOnline = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var i;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (this.context.web3Providers.length) {
              _context.next = 2;
              break;
            }
            throw new NoProviderError();
          case 2:
            i = 0;
          case 3:
            if (!(i < this.context.web3Providers.length)) {
              _context.next = 12;
              break;
            }
            _context.next = 6;
            return this.isUp();
          case 6:
            if (!_context.sent) {
              _context.next = 8;
              break;
            }
            return _context.abrupt("return");
          case 8:
            this.shiftProvider();
          case 9:
            i++;
            _context.next = 3;
            break;
          case 12:
            throw new NoNodesAvailableError("web3");
          case 13:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function ensureOnline() {
      return _ensureOnline.apply(this, arguments);
    }
    return ensureOnline;
  }()
  /**
   * Returns a contract instance at the given address
   *
   * @param address Contract instance address
   * @param abi The Application Binary Inteface of the contract
   * @return A contract instance attached to the given address
   */
  ;
  _proto.attachContract = function attachContract(address, abi) {
    if (!address || !isAddress(address)) throw new InvalidAddressError();else if (!abi) throw new InvalidContractAbiError();
    var signer = this.getConnectedSigner();
    return new Contract(address, abi, signer);
  }
  /** Calculates the expected maximum gas fee */;
  _proto.getMaxFeePerGas = function getMaxFeePerGas() {
    return this.getConnectedSigner().getFeeData().then(function (feeData) {
      if (!feeData.maxFeePerGas) {
        throw new CannotEstimateGasError();
      }
      return feeData.maxFeePerGas.toBigInt();
    });
  };
  _proto.getApproximateGasFee = function getApproximateGasFee(estimatedFee) {
    var _this = this;
    return this.getMaxFeePerGas().then(function (maxFeePerGas) {
      var max = estimatedFee * maxFeePerGas;
      var factor = _this.context.gasFeeEstimationFactor * Web3Module.PRECISION_FACTOR_BASE;
      var average = max * BigInt(Math.trunc(factor)) / BigInt(Web3Module.PRECISION_FACTOR_BASE);
      return {
        average: average,
        max: max
      };
    });
  }
  /** Returns the current DAO factory address */;
  _proto.getDaoFactoryAddress = function getDaoFactoryAddress() {
    if (!this.context.daoFactoryAddress) {
      throw new NoDaoFactory();
    }
    return this.context.daoFactoryAddress;
  };
  return Web3Module;
}();
Web3Module.PRECISION_FACTOR_BASE = 1000;

var IPFSModule = /*#__PURE__*/function () {
  function IPFSModule(context) {
    var _context$ipfs;
    this.clientIdx = -1;
    this.clients = [];
    // Storing client data in the private module's scope to prevent external mutation
    if ((_context$ipfs = context.ipfs) != null && _context$ipfs.length) {
      this.clients = context.ipfs;
      this.clientIdx = Math.floor(Math.random() * context.ipfs.length);
    }
  }
  var _proto = IPFSModule.prototype;
  _proto.getClient = function getClient() {
    if (!this.clients.length || !this.clients[this.clientIdx]) {
      throw new ClientNotInitializedError("ipfs");
    }
    return this.clients[this.clientIdx];
  }
  /**
   * Starts using the next available IPFS endpoint
   */;
  _proto.shiftClient = function shiftClient() {
    var _this$clients;
    if (!this.clients.length) {
      throw new ClientNotInitializedError("ipfs");
    } else if (((_this$clients = this.clients) == null ? void 0 : _this$clients.length) < 2) {
      throw new NoNodesAvailableError("ipfs");
    }
    this.clientIdx = (this.clientIdx + 1) % this.clients.length;
  }
  /** Returns `true` if the current client is on line */;
  _proto.isUp = function isUp() {
    var _this$clients2;
    if (!((_this$clients2 = this.clients) != null && _this$clients2.length)) return Promise.resolve(false);
    return this.getClient().nodeInfo().then(function () {
      return true;
    })["catch"](function () {
      return false;
    });
  };
  _proto.ensureOnline = /*#__PURE__*/function () {
    var _ensureOnline = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var i, _this$clients3;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (this.clients.length) {
              _context.next = 2;
              break;
            }
            throw new ClientNotInitializedError("ipfs");
          case 2:
            i = 0;
          case 3:
            if (!(i < ((_this$clients3 = this.clients) == null ? void 0 : _this$clients3.length))) {
              _context.next = 12;
              break;
            }
            _context.next = 6;
            return this.isUp();
          case 6:
            if (!_context.sent) {
              _context.next = 8;
              break;
            }
            return _context.abrupt("return");
          case 8:
            this.shiftClient();
          case 9:
            i++;
            _context.next = 3;
            break;
          case 12:
            throw new NoNodesAvailableError("ipfs");
          case 13:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function ensureOnline() {
      return _ensureOnline.apply(this, arguments);
    }
    return ensureOnline;
  }();
  _proto.getOnlineClient = function getOnlineClient() {
    var _this = this;
    return this.ensureOnline().then(function () {
      return _this.getClient();
    });
  }
  // IPFS METHODS
  ;
  _proto.add =
  /*#__PURE__*/
  function () {
    var _add = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(input) {
      var _this2 = this;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", this.runAndRetryHelper(function () {
              return _this2.getClient().add(input);
            }).then(function (res) {
              return res.hash;
            }));
          case 1:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function add(_x) {
      return _add.apply(this, arguments);
    }
    return add;
  }();
  _proto.pin = function pin(input) {
    var _this3 = this;
    return this.runAndRetryHelper(function () {
      return _this3.getClient().pin(input);
    });
  };
  _proto.fetchBytes = function fetchBytes(cid) {
    var _this4 = this;
    return this.runAndRetryHelper(function () {
      return _this4.getClient().cat(cid);
    });
  };
  _proto.runAndRetryHelper = function runAndRetryHelper(f) {
    var _this5 = this;
    if (!this.clients.length) {
      throw new ClientNotInitializedError("ipfs");
    }
    var retries = this.clients.length;
    return runAndRetry({
      func: f,
      onFail: function onFail(e) {
        if (e instanceof ClientError) {
          if (e.response.status < 500) {
            // If the error code is not a 5XX means the
            // error is not generated by the server
            throw new IpfsError(e);
          }
        }
        retries--;
        _this5.shiftClient();
      },
      shouldRetry: function shouldRetry() {
        return retries > 0;
      }
    });
  };
  _proto.fetchString = function fetchString(cid) {
    return this.fetchBytes(cid).then(function (bytes) {
      return new TextDecoder().decode(bytes);
    })["catch"](function (e) {
      throw new DataDecodingError(e.message);
    });
  };
  return IPFSModule;
}();

var _templateObject$4;
var QueryStatus = /*#__PURE__*/gql(_templateObject$4 || (_templateObject$4 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n{\n  _meta{\n    deployment\n  }\n}\n"])));

var GraphqlModule = /*#__PURE__*/function () {
  function GraphqlModule(context) {
    var _context$graphql;
    this.clientIdx = -1;
    this.clients = [];
    if ((_context$graphql = context.graphql) != null && _context$graphql.length) {
      this.clients = context.graphql;
      this.clientIdx = Math.floor(Math.random() * context.graphql.length);
    }
  }
  /**
   * Get the current graphql client
   * @returns {GraphQLClient}
   */
  var _proto = GraphqlModule.prototype;
  _proto.getClient = function getClient() {
    if (!this.clients.length || !this.clients[this.clientIdx]) {
      throw new ClientNotInitializedError("graphql");
    }
    return this.clients[this.clientIdx];
  }
  /**
   * Starts using the next available Graphql endpoint
   * @returns {void}
   */;
  _proto.shiftClient = function shiftClient() {
    if (!this.clients.length) {
      throw new ClientNotInitializedError("graphql");
    } else if (this.clients.length < 2) {
      throw new NoNodesAvailableError("graphql");
    }
    this.clientIdx = (this.clientIdx + 1) % this.clients.length;
  }
  /**
   * Checks if the current node is online
   * @returns {Promise<boolean>}
   */;
  _proto.isUp = function isUp() {
    return this.getClient().request(QueryStatus).then(function (res) {
      var _res$_meta;
      return !!((_res$_meta = res._meta) != null && _res$_meta.deployment);
    })["catch"](function () {
      return false;
    });
  }
  /**
   * Ensures that the graphql is online.
   * If the current node is not online
   * it will shift to the next one and
   * repeat until it finds an online
   * node. In the case that there are no
   * nodes or none of them is available
   * it will throw an error
   * @returns {Promise<void>}
   */;
  _proto.ensureOnline =
  /*#__PURE__*/
  function () {
    var _ensureOnline = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var i;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (this.clients.length) {
              _context.next = 2;
              break;
            }
            throw new ClientNotInitializedError("graphql");
          case 2:
            i = 0;
          case 3:
            if (!(i < this.clients.length)) {
              _context.next = 12;
              break;
            }
            _context.next = 6;
            return this.isUp();
          case 6:
            if (!_context.sent) {
              _context.next = 8;
              break;
            }
            return _context.abrupt("return");
          case 8:
            this.shiftClient();
          case 9:
            i++;
            _context.next = 3;
            break;
          case 12:
            throw new NoNodesAvailableError("graphql");
          case 13:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function ensureOnline() {
      return _ensureOnline.apply(this, arguments);
    }
    return ensureOnline;
  }();
  _proto.request = function request(_ref) {
    var _this = this;
    var query = _ref.query,
      params = _ref.params,
      name = _ref.name;
    if (!this.clients.length) {
      throw new ClientNotInitializedError("graphql");
    }
    var retries = this.clients.length;
    return runAndRetry({
      func: function func() {
        return _this.getClient().request(query, params);
      },
      onFail: function onFail(e) {
        if (e instanceof ClientError$1) {
          // If the error code is not a 5XX means the
          // error is not generated by the server
          if (e.response.status < 500) {
            throw new GraphQLError(name || "", e);
          }
        }
        retries--;
        _this.shiftClient();
      },
      shouldRetry: function shouldRetry() {
        return retries > 0;
      }
    });
  };
  return GraphqlModule;
}();

/**
 * Provides the low level foundation so that subclasses have ready-made access to Web3, IPFS and GraphQL primitives
 */
var ClientCore = function ClientCore(context) {
  this.web3 = new Web3Module(context);
  this.ipfs = new IPFSModule(context);
  this.graphql = new GraphqlModule(context);
};

var _SupportedNetworksToG, _GRAPHQL_NODES, _IPFS_NODES, _LIVE_CONTRACTS;
var UNSUPPORTED_PROPOSAL_METADATA_LINK = {
  title: "(unsupported metadata link)",
  summary: "(the link to the metadata is not supported)",
  description: "(the link to the metadata is not supported)",
  resources: []
};
var EMPTY_PROPOSAL_METADATA_LINK = {
  title: "(the proposal has no metadata)",
  summary: "(the current proposal does not have any content defined)",
  description: "(the current proposal does not have any content defined)",
  resources: []
};
var UNAVAILABLE_PROPOSAL_METADATA = {
  title: "(unavailable metadata)",
  summary: "(the proposal metadata is not available)",
  description: "(the proposal metadata is not available)",
  resources: []
};
var getGraphqlNode = function getGraphqlNode(netowrk) {
  return "https://subgraph.satsuma-prod.com/qHR2wGfc5RLi6/aragon/osx-" + SupportedNetworksToGraphqlNetworks[netowrk] + "/api";
};
var SupportedNetworksToGraphqlNetworks = (_SupportedNetworksToG = {}, _SupportedNetworksToG[SupportedNetwork.MAINNET] = "mainnet", _SupportedNetworksToG[SupportedNetwork.GOERLI] = "goerli", _SupportedNetworksToG[SupportedNetwork.POLYGON] = "polygon", _SupportedNetworksToG[SupportedNetwork.MUMBAI] = "mumbai", _SupportedNetworksToG);
var GRAPHQL_NODES = (_GRAPHQL_NODES = {}, _GRAPHQL_NODES[SupportedNetwork.MAINNET] = [{
  url: /*#__PURE__*/getGraphqlNode(SupportedNetwork.MAINNET)
}], _GRAPHQL_NODES[SupportedNetwork.GOERLI] = [{
  url: /*#__PURE__*/getGraphqlNode(SupportedNetwork.GOERLI)
}], _GRAPHQL_NODES[SupportedNetwork.POLYGON] = [{
  url: /*#__PURE__*/getGraphqlNode(SupportedNetwork.POLYGON)
}], _GRAPHQL_NODES[SupportedNetwork.MUMBAI] = [{
  url: /*#__PURE__*/getGraphqlNode(SupportedNetwork.MUMBAI)
}], _GRAPHQL_NODES);
var IPFS_ENDPOINTS = {
  prod: [{
    url: "https://ipfs-0.aragon.network",
    headers: {
      "X-API-KEY": "b477RhECf8s8sdM7XrkLBs2wHc4kCMwpbcFC55Kt"
    }
  }, {
    url: "https://ipfs-1.aragon.network",
    headers: {
      "X-API-KEY": "b477RhECf8s8sdM7XrkLBs2wHc4kCMwpbcFC55Kt"
    }
  }],
  test: [{
    url: "https://testing-ipfs-0.aragon.network",
    headers: {
      "X-API-KEY": "b477RhECf8s8sdM7XrkLBs2wHc4kCMwpbcFC55Kt"
    }
  }]
};
var IPFS_NODES = (_IPFS_NODES = {}, _IPFS_NODES[SupportedNetwork.MAINNET] = IPFS_ENDPOINTS.prod, _IPFS_NODES[SupportedNetwork.GOERLI] = IPFS_ENDPOINTS.test, _IPFS_NODES[SupportedNetwork.POLYGON] = IPFS_ENDPOINTS.prod, _IPFS_NODES[SupportedNetwork.MUMBAI] = IPFS_ENDPOINTS.test, _IPFS_NODES);
var LIVE_CONTRACTS = (_LIVE_CONTRACTS = {}, _LIVE_CONTRACTS[SupportedNetwork.MAINNET] = {
  daoFactory: activeContractsList.mainnet.DAOFactory,
  pluginSetupProcessor: activeContractsList.mainnet.PluginRepoFactory,
  multisigRepo: activeContractsList.mainnet["multisig-repo"],
  adminRepo: activeContractsList.mainnet["admin-repo"],
  addresslistVotingRepo: activeContractsList.mainnet["address-list-voting-repo"],
  tokenVotingRepo: activeContractsList.mainnet["token-voting-repo"],
  multisigSetup: activeContractsList.mainnet.MultisigSetup,
  adminSetup: activeContractsList.mainnet.AdminSetup,
  addresslistVotingSetup: activeContractsList.mainnet.AddresslistVotingSetup,
  tokenVotingSetup: activeContractsList.mainnet.TokenVotingSetup
}, _LIVE_CONTRACTS[SupportedNetwork.GOERLI] = {
  daoFactory: activeContractsList.goerli.DAOFactory,
  pluginSetupProcessor: activeContractsList.goerli.PluginSetupProcessor,
  multisigRepo: activeContractsList.goerli["multisig-repo"],
  adminRepo: activeContractsList.goerli["admin-repo"],
  addresslistVotingRepo: activeContractsList.goerli["address-list-voting-repo"],
  tokenVotingRepo: activeContractsList.goerli["token-voting-repo"],
  multisigSetup: activeContractsList.goerli.MultisigSetup,
  adminSetup: activeContractsList.goerli.AdminSetup,
  addresslistVotingSetup: activeContractsList.goerli.AddresslistVotingSetup,
  tokenVotingSetup: activeContractsList.goerli.TokenVotingSetup
}, _LIVE_CONTRACTS[SupportedNetwork.MUMBAI] = {
  daoFactory: activeContractsList.mumbai.DAOFactory,
  pluginSetupProcessor: activeContractsList.mumbai.PluginSetupProcessor,
  multisigRepo: activeContractsList.mumbai["multisig-repo"],
  adminRepo: activeContractsList.mumbai["admin-repo"],
  addresslistVotingRepo: activeContractsList.mumbai["address-list-voting-repo"],
  tokenVotingRepo: activeContractsList.mumbai["token-voting-repo"],
  multisigSetup: activeContractsList.mumbai.MultisigSetup,
  adminSetup: activeContractsList.mumbai.AdminSetup,
  addresslistVotingSetup: activeContractsList.mumbai.AddresslistVotingSetup,
  tokenVotingSetup: activeContractsList.mumbai.TokenVotingSetup,
  ensRegistry: activeContractsList.mumbai.ENSRegistry
}, _LIVE_CONTRACTS[SupportedNetwork.POLYGON] = {
  daoFactory: activeContractsList.polygon.DAOFactory,
  pluginSetupProcessor: activeContractsList.polygon.PluginSetupProcessor,
  multisigRepo: activeContractsList.polygon["multisig-repo"],
  adminRepo: activeContractsList.polygon["admin-repo"],
  addresslistVotingRepo: activeContractsList.polygon["address-list-voting-repo"],
  tokenVotingRepo: activeContractsList.polygon["token-voting-repo"],
  multisigSetup: activeContractsList.polygon.MultisigSetup,
  adminSetup: activeContractsList.polygon.AdminSetup,
  addresslistVotingSetup: activeContractsList.polygon.AddresslistVotingSetup,
  tokenVotingSetup: activeContractsList.polygon.TokenVotingSetup,
  ensRegistry: activeContractsList.polygon.ENSRegistry
}, _LIVE_CONTRACTS);

var _process, _process$env;
var DEFAULT_GAS_FEE_ESTIMATION_FACTOR = 0.625;
var supportedProtocols = ["https:"];
if (typeof process !== "undefined" && (_process = process) != null && (_process$env = _process.env) != null && _process$env.TESTING) {
  supportedProtocols.push("http:");
}
var Context = /*#__PURE__*/function () {
  // INTERNAL CONTEXT STATE
  /**
   * @param {Object} params
   *
   * @constructor
   */
  function Context(params) {
    this.state = {};
    this.overriden = {
      daoFactoryAddress: false,
      ensRegistryAddress: false,
      gasFeeEstimationFactor: false,
      ipfsNodes: false,
      graphqlNodes: false
    };
    // set network to mainnet, overrided by the value of params
    var mergedParams = Object.assign({
      network: "mainnet"
    }, params);
    this.set(mergedParams);
  }
  var _proto = Context.prototype;
  _proto.set = function set(contextParams) {
    var _contextParams$graphq, _contextParams$ipfsNo;
    if (contextParams.network) {
      this.state.network = Context.resolveNetwork(contextParams.network, contextParams.ensRegistryAddress);
      // once the network is resolved set default values
      this.setNetworkDefaults();
    }
    if (contextParams.signer) {
      this.state.signer = contextParams.signer;
    }
    if (contextParams.web3Providers || Array.isArray(contextParams.web3Providers) && contextParams.web3Providers.length) {
      this.state.web3Providers = Context.resolveWeb3Providers(contextParams.web3Providers, this.state.network);
    }
    if ((_contextParams$graphq = contextParams.graphqlNodes) != null && _contextParams$graphq.length) {
      this.state.graphql = Context.resolveGraphql(contextParams.graphqlNodes);
      this.overriden.graphqlNodes = true;
    }
    if ((_contextParams$ipfsNo = contextParams.ipfsNodes) != null && _contextParams$ipfsNo.length) {
      this.state.ipfs = Context.resolveIpfs(contextParams.ipfsNodes);
      this.overriden.ipfsNodes = true;
    }
    if (contextParams.daoFactoryAddress) {
      this.state.daoFactoryAddress = contextParams.daoFactoryAddress;
      this.overriden.daoFactoryAddress = true;
    }
    if (contextParams.ensRegistryAddress) {
      this.state.ensRegistryAddress = contextParams.ensRegistryAddress;
      this.overriden.ensRegistryAddress = true;
    }
    if (contextParams.gasFeeEstimationFactor) {
      this.state.gasFeeEstimationFactor = Context.resolveGasFeeEstimationFactor(contextParams.gasFeeEstimationFactor);
      this.overriden.gasFeeEstimationFactor = true;
    }
  };
  _proto.setNetworkDefaults = function setNetworkDefaults() {
    var _GRAPHQL_NODES$networ, _IPFS_NODES$networkNa;
    var networkName = this.network.name;
    if (!((_GRAPHQL_NODES$networ = GRAPHQL_NODES[networkName]) != null && _GRAPHQL_NODES$networ.length) || !((_IPFS_NODES$networkNa = IPFS_NODES[networkName]) != null && _IPFS_NODES$networkNa.length) || !LIVE_CONTRACTS[networkName]) {
      throw new UnsupportedNetworkError(networkName);
    }
    if (!this.overriden.graphqlNodes) {
      this.state.graphql = Context.resolveGraphql(GRAPHQL_NODES[networkName]);
    }
    if (!this.overriden.ipfsNodes) {
      this.state.ipfs = Context.resolveIpfs(IPFS_NODES[networkName]);
    }
    if (!this.overriden.daoFactoryAddress) {
      this.state.daoFactoryAddress = LIVE_CONTRACTS[networkName].daoFactory;
    }
    if (!this.overriden.ensRegistryAddress) {
      var ensRegistry = LIVE_CONTRACTS[networkName].ensRegistry;
      if (!ensRegistry) {
        ensRegistry = this.network.ensAddress;
      }
      this.state.ensRegistryAddress = ensRegistry;
    }
    if (!this.overriden.gasFeeEstimationFactor) {
      this.state.gasFeeEstimationFactor = DEFAULT_GAS_FEE_ESTIMATION_FACTOR;
    }
  }
  // GETTERS
  /**
   * Getter for the network
   *
   * @var network
   *
   * @returns {Networkish}
   *
   * @public
   */;
  // INTERNAL HELPERS
  Context.resolveNetwork = function resolveNetwork(networkish, ensRegistryAddress) {
    var network = getNetwork(networkish);
    var networkName = network.name;
    if (!SupportedNetworksArray.includes(networkName)) {
      throw new UnsupportedNetworkError(networkName);
    }
    if (ensRegistryAddress) {
      if (!isAddress(ensRegistryAddress)) {
        throw new InvalidAddressError();
      } else {
        network.ensAddress = ensRegistryAddress;
      }
    }
    if (!network.ensAddress) {
      var ensAddress = LIVE_CONTRACTS[networkName].ensRegistry;
      if (!ensAddress) {
        throw new UnsupportedNetworkError(networkName);
      }
      network.ensAddress = ensAddress;
    }
    return network;
  };
  Context.resolveWeb3Providers = function resolveWeb3Providers(endpoints, network) {
    if (Array.isArray(endpoints)) {
      return endpoints.map(function (item) {
        if (typeof item === "string") {
          var url = new URL(item);
          if (!supportedProtocols.includes(url.protocol)) {
            throw new UnsupportedProtocolError(url.protocol);
          }
          return new JsonRpcProvider(url.href, network);
        }
        return item;
      });
    } else if (typeof endpoints === "string") {
      var url = new URL(endpoints);
      if (!supportedProtocols.includes(url.protocol)) {
        throw new UnsupportedProtocolError(url.protocol);
      }
      return [new JsonRpcProvider(url.href, network)];
    } else {
      return [endpoints];
    }
  };
  Context.resolveIpfs = function resolveIpfs(configs) {
    var clients = [];
    configs.forEach(function (config) {
      var url = new URL(config.url);
      if (!supportedProtocols.includes(url.protocol)) {
        throw new UnsupportedProtocolError(url.protocol);
      }
      clients.push(new Client$1(url, config.headers));
    });
    return clients;
  };
  Context.resolveGraphql = function resolveGraphql(endpoints) {
    var clients = [];
    endpoints.forEach(function (endpoint) {
      var url = new URL(endpoint.url);
      if (!supportedProtocols.includes(url.protocol)) {
        throw new UnsupportedProtocolError(url.protocol);
      }
      clients.push(new GraphQLClient(url.href));
    });
    return clients;
  };
  Context.resolveGasFeeEstimationFactor = function resolveGasFeeEstimationFactor(gasFeeEstimationFactor) {
    if (gasFeeEstimationFactor < 0 || gasFeeEstimationFactor > 1) {
      throw new Error("Gas estimation factor value should be a number between 0 and 1");
    }
    return gasFeeEstimationFactor;
  };
  _createClass(Context, [{
    key: "network",
    get: function get() {
      return this.state.network;
    }
    /**
     * Getter for the Signer
     *
     * @var signer
     *
     * @returns {Signer}
     *
     * @public
     */
  }, {
    key: "ensRegistryAddress",
    get: function get() {
      return this.state.ensRegistryAddress;
    }
    /**
     * Getter for the Signer
     *
     * @var signer
     *
     * @returns {Signer}
     *
     * @public
     */
  }, {
    key: "signer",
    get: function get() {
      return this.state.signer;
    }
    /**
     * Getter for the web3 providers
     *
     * @var web3Providers
     *
     * @returns {JsonRpcProvider[]}
     *
     * @public
     */
  }, {
    key: "web3Providers",
    get: function get() {
      return this.state.web3Providers || [];
    }
    /**
     * Getter for daoFactoryAddress property
     *
     * @var daoFactoryAddress
     *
     * @returns {string}
     *
     * @public
     */
  }, {
    key: "daoFactoryAddress",
    get: function get() {
      return this.state.daoFactoryAddress;
    }
    /**
     * Getter for the gas fee reducer used in estimations
     *
     * @var gasFeeEstimationFactor
     *
     * @returns {number}
     *
     * @public
     */
  }, {
    key: "gasFeeEstimationFactor",
    get: function get() {
      return this.state.gasFeeEstimationFactor;
    }
    /**
     * Getter for the IPFS http client
     *
     * @var ipfs
     *
     * @returns {IpfsClient[]}
     *
     * @public
     */
  }, {
    key: "ipfs",
    get: function get() {
      return this.state.ipfs;
    }
    /**
     * Getter for the GraphQL client
     *
     * @var graphql
     *
     * @returns {GraphQLClient[]}
     *
     * @public
     */
  }, {
    key: "graphql",
    get: function get() {
      return this.state.graphql;
    }
  }]);
  return Context;
}();

var ContextPlugin = /*#__PURE__*/function (_Context) {
  _inheritsLoose(ContextPlugin, _Context);
  // INTERNAL CONTEXT STATE
  /**
   * @param {ContextPluginParams} params The parameters for the client context
   *
   * @constructor
   */
  function ContextPlugin(params) {
    return _Context.call(this, params) || this;
  }
  /**
   * Generate a plugin context from a client clontext and a plugin address
   *
   * @param {Context} ctx
   * @param {string} pluginAddress
   * @return {*}  {ContextPlugin}
   * @memberof ContextPlugin
   */
  ContextPlugin.fromContext = function fromContext(ctx) {
    var ctxPlugin = new ContextPlugin({});
    Object.assign(ctxPlugin, ctx);
    return ctxPlugin;
  };
  var _proto = ContextPlugin.prototype;
  _proto.set = function set(contextParams) {
    _Context.prototype.set.call(this, contextParams);
  };
  return ContextPlugin;
}(Context);

function unwrapProposalParams(params) {
  var _params$actions, _params$executeOnPass, _params$creatorVote;
  return [params.metadataUri, (_params$actions = params.actions) != null ? _params$actions : [],
  // TODO: Verify => seconds?
  params.startDate ? Math.floor(params.startDate.getTime() / 1000) : 0,
  // TODO: Verify => seconds?
  params.endDate ? Math.floor(params.endDate.getTime() / 1000) : 0, (_params$executeOnPass = params.executeOnPass) != null ? _params$executeOnPass : false, (_params$creatorVote = params.creatorVote) != null ? _params$creatorVote : VoteValues.ABSTAIN];
}
function computeProposalStatus(proposal) {
  var now = new Date();
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  if (proposal.executed) {
    return ProposalStatus.EXECUTED;
  }
  if (startDate >= now) {
    return ProposalStatus.PENDING;
  }
  if (proposal.potentiallyExecutable || proposal.earlyExecutable) {
    return ProposalStatus.SUCCEEDED;
  }
  if (endDate >= now) {
    return ProposalStatus.ACTIVE;
  }
  return ProposalStatus.DEFEATED;
}
function computeProposalStatusFilter(status) {
  var where = {};
  var now = Math.round(new Date().getTime() / 1000).toString();
  switch (status) {
    case ProposalStatus.PENDING:
      where = {
        startDate_gte: now
      };
      break;
    case ProposalStatus.ACTIVE:
      where = {
        startDate_lt: now,
        endDate_gte: now,
        executed: false
      };
      break;
    case ProposalStatus.EXECUTED:
      where = {
        executed: true
      };
      break;
    case ProposalStatus.SUCCEEDED:
      where = {
        potentiallyExecutable: true,
        endDate_lt: now
      };
      break;
    case ProposalStatus.DEFEATED:
      where = {
        potentiallyExecutable: false,
        endDate_lt: now,
        executed: false
      };
      break;
    default:
      throw new Error("invalid proposal status");
  }
  return where;
}
function findLog(receipt, iface, eventName) {
  return receipt.logs.find(function (log) {
    return log.topics[0] === id(iface.getEvent(eventName).format("sighash"));
  });
}
function votingModeToContracts(votingMode) {
  switch (votingMode) {
    case VotingMode.STANDARD:
      return 0;
    case VotingMode.EARLY_EXECUTION:
      return 1;
    case VotingMode.VOTE_REPLACEMENT:
      return 2;
    default:
      throw new InvalidVotingModeError();
  }
}
function votingModeFromContracts(votingMode) {
  switch (votingMode) {
    case 0:
      return VotingMode.STANDARD;
    case 1:
      return VotingMode.EARLY_EXECUTION;
    case 2:
      return VotingMode.VOTE_REPLACEMENT;
    default:
      throw new InvalidVotingModeError();
  }
}

function decodeUpdatePluginSettingsAction(data) {
  var votingInterface = MajorityVotingBase__factory.createInterface();
  var hexBytes = bytesToHex(data);
  var expectedfunction = votingInterface.getFunction("updateVotingSettings");
  var result = votingInterface.decodeFunctionData(expectedfunction, hexBytes);
  return pluginSettingsFromContract(result);
}
function encodeUpdateVotingSettingsAction(params) {
  var votingInterface = MajorityVotingBase__factory.createInterface();
  var args = votingSettingsToContract(params);
  // get hex bytes
  var hexBytes = votingInterface.encodeFunctionData("updateVotingSettings", [args]);
  // Strip 0x => encode in Uint8Array
  return hexToBytes(hexBytes);
}
function pluginSettingsFromContract(result) {
  return {
    votingMode: votingModeFromContracts(result[0][0]),
    supportThreshold: decodeRatio(result[0][1], 6),
    minParticipation: decodeRatio(result[0][2], 6),
    minDuration: result[0][3].toNumber(),
    minProposerVotingPower: BigInt(result[0][4])
  };
}
function votingSettingsToContract(params) {
  return {
    votingMode: BigNumber.from(votingModeToContracts(params.votingMode || VotingMode.STANDARD)),
    supportThreshold: encodeRatio(params.supportThreshold, 6),
    minParticipation: encodeRatio(params.minParticipation, 6),
    minDuration: BigNumber.from(params.minDuration),
    minProposerVotingPower: BigNumber.from(params.minProposerVotingPower || 0)
  };
}
function getFunctionFragment(data, availableFunctions) {
  var hexBytes = bytesToHex(data);
  var iface = new Interface(availableFunctions);
  return iface.getFunction(hexBytes.substring(0, 10));
}

var Permissions = {
  UPGRADE_PERMISSION: "UPGRADE_PERMISSION",
  SET_METADATA_PERMISSION: "SET_METADATA_PERMISSION",
  EXECUTE_PERMISSION: "EXECUTE_PERMISSION",
  WITHDRAW_PERMISSION: "WITHDRAW_PERMISSION",
  SET_SIGNATURE_VALIDATOR_PERMISSION: "SET_SIGNATURE_VALIDATOR_PERMISSION",
  SET_TRUSTED_FORWARDER_PERMISSION: "SET_TRUSTED_FORWARDER_PERMISSION",
  ROOT_PERMISSION: "ROOT_PERMISSION",
  CREATE_VERSION_PERMISSION: "CREATE_VERSION_PERMISSION",
  REGISTER_PERMISSION: "REGISTER_PERMISSION",
  REGISTER_DAO_PERMISSION: "REGISTER_DAO_PERMISSION",
  REGISTER_ENS_SUBDOMAIN_PERMISSION: "REGISTER_ENS_SUBDOMAIN_PERMISSION",
  MINT_PERMISSION: "MINT_PERMISSION",
  MERKLE_MINT_PERMISSION: "MERKLE_MINT_PERMISSION",
  MODIFY_ALLOWLIST_PERMISSION: "MODIFY_ALLOWLIST_PERMISSION",
  SET_CONFIGURATION_PERMISSION: "SET_CONFIGURATION_PERMISSION"
};
var PermissionIds = /*#__PURE__*/Object.entries(Permissions).reduce(function (acc, _ref) {
  var _extends2;
  var k = _ref[0],
    v = _ref[1];
  return _extends({}, acc, (_extends2 = {}, _extends2[k + "_ID"] = keccak256(toUtf8Bytes(v)), _extends2));
}, {});
Object.freeze(Permissions);
Object.freeze(PermissionIds);

function unwrapDepositParams(params) {
  var _params$tokenAddress;
  return [params.daoAddressOrEns, params.amount, (_params$tokenAddress = params == null ? void 0 : params.tokenAddress) != null ? _params$tokenAddress : AddressZero, ""];
}
function toDaoDetails(dao, metadata) {
  return {
    address: dao.id,
    ensDomain: dao.subdomain + ".dao.eth",
    metadata: {
      name: metadata.name,
      description: metadata.description,
      avatar: metadata.avatar || undefined,
      links: metadata.links
    },
    creationDate: new Date(parseInt(dao.createdAt) * 1000),
    // TODO update when new subgraph schema is deployed
    plugins: dao.plugins.map(function (plugin) {
      return {
        id: plugin.appliedPluginRepo.subdomain + ".plugin.dao.eth",
        release: plugin.appliedVersion.release.release,
        build: plugin.appliedVersion.build,
        instanceAddress: plugin.appliedPreparation.pluginAddress
      };
    })
  };
}
function toDaoListItem(dao, metadata) {
  return {
    address: dao.id,
    ensDomain: dao.subdomain + ".dao.eth",
    metadata: {
      name: metadata.name,
      description: metadata.description,
      avatar: metadata.avatar || undefined
    },
    plugins: dao.plugins.map(function (plugin) {
      return {
        id: plugin.appliedPluginRepo.subdomain + ".plugin.dao.eth",
        release: plugin.appliedVersion.release.release,
        build: plugin.appliedVersion.build,
        instanceAddress: plugin.appliedPreparation.pluginAddress
      };
    })
  };
}
function toAssetBalance(balance) {
  var updateDate = new Date(parseInt(balance.lastUpdated) * 1000);
  if (balance.__typename === "NativeBalance") {
    return {
      type: TokenType.NATIVE,
      balance: BigInt(balance.balance),
      updateDate: updateDate
    };
  } else if (balance.__typename === "ERC721Balance") {
    return {
      type: TokenType.ERC721,
      name: balance.token.name,
      symbol: balance.token.symbol,
      updateDate: updateDate,
      address: balance.token.id
    };
  } else {
    return {
      type: TokenType.ERC20,
      address: balance.token.id,
      name: balance.token.name,
      symbol: balance.token.symbol,
      decimals: balance.token.decimals,
      balance: BigInt(balance.balance),
      updateDate: updateDate
    };
  }
}
function toTokenTransfer(transfer) {
  var creationDate = new Date(parseInt(transfer.createdAt) * 1000);
  if (transfer.__typename === "NativeTransfer") {
    var _transfer$proposal;
    if (transfer.type === SubgraphTransferType.DEPOSIT) {
      return {
        type: TransferType.DEPOSIT,
        tokenType: TokenType.NATIVE,
        amount: BigInt(transfer.amount),
        creationDate: creationDate,
        transactionId: transfer.txHash,
        from: transfer.from,
        to: transfer.to
      };
    }
    return {
      type: TransferType.WITHDRAW,
      tokenType: TokenType.NATIVE,
      amount: BigInt(transfer.amount),
      creationDate: creationDate,
      transactionId: transfer.txHash,
      proposalId: ((_transfer$proposal = transfer.proposal) == null ? void 0 : _transfer$proposal.id) || "",
      to: transfer.to,
      from: transfer.from
    };
  } else if (transfer.__typename === "ERC721Transfer") {
    var _transfer$proposal2;
    if (transfer.type === SubgraphTransferType.DEPOSIT) {
      return {
        type: TransferType.DEPOSIT,
        tokenType: TokenType.ERC721,
        token: {
          address: transfer.token.id,
          name: transfer.token.name,
          symbol: transfer.token.symbol
        },
        creationDate: creationDate,
        transactionId: transfer.txHash,
        from: transfer.from,
        to: transfer.to
      };
    }
    return {
      type: TransferType.WITHDRAW,
      tokenType: TokenType.ERC721,
      token: {
        address: transfer.token.id,
        name: transfer.token.name,
        symbol: transfer.token.symbol
      },
      creationDate: creationDate,
      transactionId: transfer.txHash,
      to: transfer.to,
      from: transfer.from,
      proposalId: ((_transfer$proposal2 = transfer.proposal) == null ? void 0 : _transfer$proposal2.id) || ""
    };
  } else {
    var _transfer$proposal3;
    if (transfer.type === SubgraphTransferType.DEPOSIT) {
      return {
        type: TransferType.DEPOSIT,
        tokenType: TokenType.ERC20,
        token: {
          address: transfer.token.id,
          name: transfer.token.name,
          symbol: transfer.token.symbol,
          decimals: transfer.token.decimals
        },
        amount: BigInt(transfer.amount),
        creationDate: creationDate,
        transactionId: transfer.txHash,
        from: transfer.from,
        to: transfer.to
      };
    }
    return {
      type: TransferType.WITHDRAW,
      tokenType: TokenType.ERC20,
      token: {
        address: transfer.token.id,
        name: transfer.token.name,
        symbol: transfer.token.symbol,
        decimals: transfer.token.decimals
      },
      amount: BigInt(transfer.amount),
      creationDate: creationDate,
      transactionId: transfer.txHash,
      to: transfer.to,
      from: transfer.from,
      proposalId: ((_transfer$proposal3 = transfer.proposal) == null ? void 0 : _transfer$proposal3.id) || ""
    };
  }
}
function toPluginRepoRelease(release, metadata) {
  return {
    release: release.release,
    currentBuild: Math.max.apply(Math, release.builds.map(function (build) {
      return build.build;
    })),
    metadata: metadata
  };
}
function toPluginRepoListItem(pluginRepo, releases) {
  return {
    address: pluginRepo.id,
    subdomain: pluginRepo.subdomain,
    releases: releases
  };
}
function toPluginRepo(pluginRepo, releaseMetadata, buildMetadata) {
  var _pluginRepo$releases, _pluginRepo$releases$, _pluginRepo$releases$2, _pluginRepo$releases$3, _pluginRepo$releases2, _pluginRepo$releases3;
  return {
    address: pluginRepo.id,
    subdomain: pluginRepo.subdomain,
    current: {
      build: {
        metadata: buildMetadata,
        // the subgraph returns only one build ordered by build number
        // in descending order, this means it's the latest build
        number: (_pluginRepo$releases = pluginRepo.releases) == null ? void 0 : (_pluginRepo$releases$ = _pluginRepo$releases[0]) == null ? void 0 : (_pluginRepo$releases$2 = _pluginRepo$releases$.builds) == null ? void 0 : (_pluginRepo$releases$3 = _pluginRepo$releases$2[0]) == null ? void 0 : _pluginRepo$releases$3.build
      },
      release: {
        metadata: releaseMetadata,
        // the subgraph returns only one realease ordered by realease number
        // in descending order, this means it's the latest realease
        number: (_pluginRepo$releases2 = pluginRepo.releases) == null ? void 0 : (_pluginRepo$releases3 = _pluginRepo$releases2[0]) == null ? void 0 : _pluginRepo$releases3.release
      }
    }
  };
}
function applyInstallatonParamsToContract(params) {
  return {
    plugin: params.pluginAddress,
    pluginSetupRef: {
      pluginSetupRepo: params.pluginRepo,
      versionTag: params.versionTag
    },
    helpersHash: keccak256(defaultAbiCoder.encode(["address[]"], [params.helpers])),
    permissions: params.permissions.map(function (permission) {
      return _extends({}, permission, {
        condition: permission.condition || AddressZero
      });
    })
  };
}
function applyUninstallationParamsToContract(params) {
  return {
    plugin: params.pluginAddress,
    pluginSetupRef: {
      pluginSetupRepo: params.pluginRepo,
      versionTag: params.versionTag
    },
    permissions: params.permissions.map(function (permission) {
      return _extends({}, permission, {
        condition: permission.condition || AddressZero
      });
    })
  };
}
function applyInstallatonParamsFromContract(result) {
  var params = result[1];
  return {
    helpersHash: params.helpersHash,
    permissions: params.permissions,
    versionTag: params.pluginSetupRef.versionTag,
    pluginAddress: params.plugin,
    pluginRepo: params.pluginSetupRef.pluginSetupRepo
  };
}
function permissionParamsToContract(params) {
  return [params.where, params.who, keccak256(toUtf8Bytes(params.permission))];
}
function permissionWithConditionParamsToContract(params) {
  return [].concat(permissionParamsToContract({
    who: params.who,
    where: params.where,
    permission: params.permission
  }), [params.condition]);
}
function permissionParamsFromContract(result) {
  var _Object$keys$find;
  return {
    where: result[0],
    who: result[1],
    permissionId: result[2],
    permission: ((_Object$keys$find = Object.keys(PermissionIds).find(function (k) {
      return PermissionIds[k] === result[2];
    })) == null ? void 0 : _Object$keys$find.replace(/_ID$/, "")) || ""
  };
}
function permissionParamsWitConditionFromContract(result) {
  return _extends({}, permissionParamsFromContract(result), {
    condition: result[3]
  });
}
function withdrawParamsFromContract(to, _value, result, tokenStandard) {
  if (tokenStandard === TokenType.ERC20) {
    return {
      type: TokenType.ERC20,
      tokenAddress: to,
      recipientAddressOrEns: result[0],
      amount: BigInt(result[1])
    };
  }
  // TODO Add ERC721 and ERC1155
  throw new Error("not implemented");
}

var AVAILABLE_FUNCTION_SIGNATURES = [/*#__PURE__*/new Contract(AddressZero, erc20ContractAbi)["interface"].getFunction("transfer").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("grant").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("grantWithCondition").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("revoke").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("setMetadata").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("setDaoURI").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("registerStandardCallback").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("setSignatureValidator").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("upgradeTo").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("upgradeToAndCall").format("minimal")];
var UNSUPPORTED_DAO_METADATA_LINK = {
  name: "(unsupported metadata link)",
  description: "(the metadata link is not supported)",
  links: []
};
var EMPTY_DAO_METADATA_LINK = {
  name: "(the DAO has no metadata)",
  description: "(the DAO did not define any content)",
  links: []
};
var UNAVAILABLE_DAO_METADATA = {
  name: "(unavailable metadata)",
  description: "(the DAO metadata is not available)",
  links: []
};
var UNSUPPORTED_RELEASE_METADATA_LINK = {
  name: "(unsupported metadata link)",
  description: "(the metadata link is not supported)",
  images: {}
};
var EMPTY_RELEASE_METADATA_LINK = {
  name: "(the release has no metadata)",
  description: "(the release did not define any content)",
  images: {}
};
var UNAVAILABLE_RELEASE_METADATA = {
  name: "(unavailable metadata)",
  description: "(the release metadata is not available)",
  images: {}
};
var UNSUPPORTED_BUILD_METADATA_LINK = {
  ui: "",
  change: "(unsupported metadata link)",
  pluginSetupABI: {
    prepareInstallation: [],
    prepareUninstallation: [],
    prepareUpdate: []
  }
};
var EMPTY_BUILD_METADATA_LINK = {
  ui: "",
  change: "(the build has no metadata)",
  pluginSetupABI: {
    prepareInstallation: [],
    prepareUninstallation: [],
    prepareUpdate: []
  }
};
var UNAVAILABLE_BUILD_METADATA = {
  ui: "",
  change: "(unavailable metadata)",
  pluginSetupABI: {
    prepareInstallation: [],
    prepareUninstallation: [],
    prepareUpdate: []
  }
};

/**
 * Methods module the SDK Generic Client
 */
var ClientMethods = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(ClientMethods, _ClientCore);
  function ClientMethods() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = ClientMethods.prototype;
  /**
   * Creates a DAO with the given settings and plugins
   *
   * @param {CreateDaoParams} params
   * @return {*}  {AsyncGenerator<DaoCreationStepValue>}
   * @memberof ClientMethods
   */
  _proto.createDao = function createDao(params) {
    var _this = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _receipt$logs, _receipt$logs2;
      var signer, daoFactoryInstance, pluginInstallationData, _iterator, _step, plugin, repo, currentRelease, latestVersion, pluginSetupProcessorAddr, pluginSetupProcessor, execPermissionFound, daoBaseAddr, _i, _pluginInstallationDa, installData, pluginSetupProcessorResponse, found, tx, receipt, daoFactoryInterface, log, pspInterface, installedLogs, parsedLog;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            signer = _this.web3.getConnectedSigner();
            if (!(params.ensSubdomain && !params.ensSubdomain.match(/^[a-z0-9\-]+$/))) {
              _context.next = 3;
              break;
            }
            throw new InvalidEnsError();
          case 3:
            daoFactoryInstance = DAOFactory__factory.connect(_this.web3.getDaoFactoryAddress(), signer);
            pluginInstallationData = [];
            _iterator = _createForOfIteratorHelperLoose(params.plugins);
          case 6:
            if ((_step = _iterator()).done) {
              _context.next = 18;
              break;
            }
            plugin = _step.value;
            repo = PluginRepo__factory.connect(plugin.id, signer);
            _context.next = 11;
            return _awaitAsyncGenerator(repo.latestRelease());
          case 11:
            currentRelease = _context.sent;
            _context.next = 14;
            return _awaitAsyncGenerator(repo["getLatestVersion(uint8)"](currentRelease));
          case 14:
            latestVersion = _context.sent;
            pluginInstallationData.push({
              pluginSetupRef: {
                pluginSetupRepo: repo.address,
                versionTag: latestVersion.tag
              },
              data: plugin.data
            });
          case 16:
            _context.next = 6;
            break;
          case 18:
            _context.next = 20;
            return _awaitAsyncGenerator(daoFactoryInstance.pluginSetupProcessor());
          case 20:
            pluginSetupProcessorAddr = _context.sent;
            pluginSetupProcessor = PluginSetupProcessor__factory.connect(pluginSetupProcessorAddr, signer);
            execPermissionFound = false; // using the DAO base because it reflects a newly created DAO the best
            _context.next = 25;
            return _awaitAsyncGenerator(daoFactoryInstance.daoBase());
          case 25:
            daoBaseAddr = _context.sent;
            _i = 0, _pluginInstallationDa = pluginInstallationData;
          case 27:
            if (!(_i < _pluginInstallationDa.length)) {
              _context.next = 39;
              break;
            }
            installData = _pluginInstallationDa[_i];
            _context.next = 31;
            return _awaitAsyncGenerator(pluginSetupProcessor.callStatic.prepareInstallation(daoBaseAddr, installData));
          case 31:
            pluginSetupProcessorResponse = _context.sent;
            found = pluginSetupProcessorResponse[1].permissions.find(function (permission) {
              return permission.permissionId === PermissionIds.EXECUTE_PERMISSION_ID;
            });
            if (!found) {
              _context.next = 36;
              break;
            }
            execPermissionFound = true;
            return _context.abrupt("break", 39);
          case 36:
            _i++;
            _context.next = 27;
            break;
          case 39:
            if (execPermissionFound) {
              _context.next = 41;
              break;
            }
            throw new MissingExecPermissionError();
          case 41:
            _context.next = 43;
            return _awaitAsyncGenerator(daoFactoryInstance.connect(signer).createDao({
              subdomain: params.ensSubdomain,
              metadata: toUtf8Bytes(params.metadataUri),
              daoURI: params.daoUri || "",
              trustedForwarder: params.trustedForwarder || AddressZero
            }, pluginInstallationData));
          case 43:
            tx = _context.sent;
            _context.next = 46;
            return {
              key: DaoCreationSteps.CREATING,
              txHash: tx.hash
            };
          case 46:
            _context.next = 48;
            return _awaitAsyncGenerator(tx.wait());
          case 48:
            receipt = _context.sent;
            daoFactoryInterface = DAORegistry__factory.createInterface(); // find dao address using the dao registry address
            log = (_receipt$logs = receipt.logs) == null ? void 0 : _receipt$logs.find(function (e) {
              return e.topics[0] === id(daoFactoryInterface.getEvent("DAORegistered").format("sighash"));
            });
            if (log) {
              _context.next = 53;
              break;
            }
            throw new Error("Failed to create DAO");
          case 53:
            // Plugin logs
            pspInterface = PluginSetupProcessor__factory.createInterface();
            installedLogs = (_receipt$logs2 = receipt.logs) == null ? void 0 : _receipt$logs2.filter(function (e) {
              return e.topics[0] === id(pspInterface.getEvent("InstallationApplied").format("sighash"));
            }); // DAO logs
            parsedLog = daoFactoryInterface.parseLog(log);
            if (parsedLog.args["dao"]) {
              _context.next = 58;
              break;
            }
            throw new Error("Failed to create DAO");
          case 58:
            _context.next = 60;
            return {
              key: DaoCreationSteps.DONE,
              address: parsedLog.args["dao"],
              pluginAddresses: installedLogs.map(function (log) {
                return pspInterface.parseLog(log).args[1];
              })
            };
          case 60:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  }
  /**
   * Pins a metadata object into IPFS and retruns the generated hash
   *
   * @param {DaoMetadata} params
   * @return {*}  {Promise<string>}
   * @memberof ClientMethods
   */;
  _proto.pinMetadata =
  /*#__PURE__*/
  function () {
    var _pinMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var cid;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.ipfs.add(JSON.stringify(params));
          case 3:
            cid = _context2.sent;
            _context2.next = 6;
            return this.ipfs.pin(cid);
          case 6:
            return _context2.abrupt("return", "ipfs://" + cid);
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](0);
            throw new IpfsPinError(_context2.t0);
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[0, 9]]);
    }));
    function pinMetadata(_x) {
      return _pinMetadata.apply(this, arguments);
    }
    return pinMetadata;
  }()
  /**
   * Deposits ether or an ERC20 token into the DAO
   *
   * @param {DepositParams} params
   * @return {*}  {AsyncGenerator<DaoDepositStepValue>}
   * @memberof ClientMethods
   */
  ;
  _proto.deposit = function deposit(params) {
    var _this2 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var signer, _unwrapDepositParams, daoAddress, amount, tokenAddress, reference, tokenInstance, currentAllowance, daoInstance, override, tx, cr, log, daoInterface, parsedLog;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            signer = _this2.web3.getConnectedSigner();
            if (!(params.type !== TokenType.NATIVE && params.type !== TokenType.ERC20)) {
              _context3.next = 3;
              break;
            }
            throw new Error("Please, use the token's transfer function directly");
          case 3:
            _unwrapDepositParams = unwrapDepositParams(params), daoAddress = _unwrapDepositParams[0], amount = _unwrapDepositParams[1], tokenAddress = _unwrapDepositParams[2], reference = _unwrapDepositParams[3];
            if (!(tokenAddress && tokenAddress !== AddressZero)) {
              _context3.next = 20;
              break;
            }
            // check current allowance
            tokenInstance = new Contract(tokenAddress, erc20ContractAbi, signer);
            _context3.t0 = _awaitAsyncGenerator;
            _context3.t1 = tokenInstance;
            _context3.next = 10;
            return _awaitAsyncGenerator(signer.getAddress());
          case 10:
            _context3.t2 = _context3.sent;
            _context3.t3 = daoAddress;
            _context3.t4 = _context3.t1.allowance.call(_context3.t1, _context3.t2, _context3.t3);
            _context3.next = 15;
            return (0, _context3.t0)(_context3.t4);
          case 15:
            currentAllowance = _context3.sent;
            _context3.next = 18;
            return {
              key: DaoDepositSteps.CHECKED_ALLOWANCE,
              allowance: currentAllowance.toBigInt()
            };
          case 18:
            if (!currentAllowance.lt(params.amount)) {
              _context3.next = 20;
              break;
            }
            return _context3.delegateYield(_asyncGeneratorDelegate(_asyncIterator(_this2.setAllowance({
              amount: params.amount,
              spender: daoAddress,
              tokenAddress: tokenAddress
            }))), "t5", 20);
          case 20:
            // Doing the transfer
            daoInstance = DAO__factory.connect(daoAddress, signer);
            override = {};
            if (tokenAddress === AddressZero) {
              // Ether
              override.value = amount;
            }
            _context3.next = 25;
            return _awaitAsyncGenerator(daoInstance.deposit(tokenAddress, amount, reference, override));
          case 25:
            tx = _context3.sent;
            _context3.next = 28;
            return {
              key: DaoDepositSteps.DEPOSITING,
              txHash: tx.hash
            };
          case 28:
            _context3.next = 30;
            return _awaitAsyncGenerator(tx.wait());
          case 30:
            cr = _context3.sent;
            log = findLog(cr, daoInstance["interface"], "Deposited");
            if (log) {
              _context3.next = 34;
              break;
            }
            throw new FailedDepositError();
          case 34:
            daoInterface = DAO__factory.createInterface();
            parsedLog = daoInterface.parseLog(log);
            if (!(!amount.toString() === parsedLog.args["amount"])) {
              _context3.next = 38;
              break;
            }
            throw new AmountMismatchError(amount, parsedLog.args["amount"].toBigInt());
          case 38:
            _context3.next = 40;
            return {
              key: DaoDepositSteps.DONE,
              amount: amount
            };
          case 40:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }))();
  }
  /**
   * Checks if the allowance is enough and updates it
   *
   * @param {SetAllowanceParams} params
   * @return {*}  {AsyncGenerator<SetAllowanceStepValue>}
   * @memberof ClientMethods
   */;
  _proto.setAllowance = function setAllowance(params) {
    var _this3 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var signer, tokenInstance, tx, cr, log, value;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            signer = _this3.web3.getConnectedSigner(); // TODO
            // add params check with yup
            tokenInstance = new Contract(params.tokenAddress, erc20ContractAbi, signer);
            _context4.next = 4;
            return _awaitAsyncGenerator(tokenInstance.approve(params.spender, params.amount));
          case 4:
            tx = _context4.sent;
            _context4.next = 7;
            return {
              key: SetAllowanceSteps.SETTING_ALLOWANCE,
              txHash: tx.hash
            };
          case 7:
            _context4.next = 9;
            return _awaitAsyncGenerator(tx.wait());
          case 9:
            cr = _context4.sent;
            log = findLog(cr, tokenInstance["interface"], "Approval");
            if (log) {
              _context4.next = 13;
              break;
            }
            throw new UpdateAllowanceError();
          case 13:
            value = log.data;
            if (!(!value || BigNumber.from(params.amount).gt(BigNumber.from(value)))) {
              _context4.next = 16;
              break;
            }
            throw new UpdateAllowanceError();
          case 16:
            _context4.next = 18;
            return {
              key: SetAllowanceSteps.ALLOWANCE_SET,
              allowance: params.amount
            };
          case 18:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }))();
  }
  /**
   * Prepare uninstallation of a plugin
   *
   * @param {PrepareUninstallationParams} params
   * @return {*}  {AsyncGenerator<PrepareUninstallationStepValue>}
   * @memberof ClientMethods
   */;
  _proto.prepareUninstallation = function prepareUninstallation(params) {
    var _this4 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var signer, networkName, _yield$_awaitAsyncGen, iplugin, _params$pluginInstall, pluginInstallationIndex, selectedInstallation, _params$uninstallatio, uninstallationParams, _params$uninstallatio2, uninstallationAbi, data, pspContract, tx, cr, log, parsedLog, permissions;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            signer = _this4.web3.getConnectedSigner();
            networkName = _this4.web3.getNetworkName();
            _context5.next = 4;
            return _awaitAsyncGenerator(_this4.graphql.request({
              query: QueryIPlugin,
              params: {
                address: params.pluginAddress.toLowerCase(),
                where: {
                  dao: params.daoAddressOrEns
                }
              },
              name: "plugin"
            }));
          case 4:
            _yield$_awaitAsyncGen = _context5.sent;
            iplugin = _yield$_awaitAsyncGen.iplugin;
            // filter specified installation
            _params$pluginInstall = params.pluginInstallationIndex, pluginInstallationIndex = _params$pluginInstall === void 0 ? 0 : _params$pluginInstall;
            selectedInstallation = iplugin.installations[pluginInstallationIndex];
            if (selectedInstallation) {
              _context5.next = 10;
              break;
            }
            throw new InstallationNotFoundError();
          case 10:
            // encode uninstallation params
            _params$uninstallatio = params.uninstallationParams, uninstallationParams = _params$uninstallatio === void 0 ? [] : _params$uninstallatio, _params$uninstallatio2 = params.uninstallationAbi, uninstallationAbi = _params$uninstallatio2 === void 0 ? [] : _params$uninstallatio2;
            data = defaultAbiCoder.encode(uninstallationAbi, uninstallationParams); // connect to psp contract
            pspContract = PluginSetupProcessor__factory.connect(LIVE_CONTRACTS[networkName].pluginSetupProcessor, signer);
            _context5.next = 15;
            return _awaitAsyncGenerator(pspContract.prepareUninstallation(params.daoAddressOrEns, {
              pluginSetupRef: {
                pluginSetupRepo: selectedInstallation.appliedPreparation.pluginRepo.id,
                versionTag: {
                  build: selectedInstallation.appliedVersion.build,
                  release: selectedInstallation.appliedVersion.release.release
                }
              },
              setupPayload: {
                plugin: params.pluginAddress,
                currentHelpers: selectedInstallation.appliedPreparation.helpers,
                data: data
              }
            }));
          case 15:
            tx = _context5.sent;
            _context5.next = 18;
            return {
              key: PrepareUninstallationSteps.PREPARING,
              txHash: tx.hash
            };
          case 18:
            _context5.next = 20;
            return _awaitAsyncGenerator(tx.wait());
          case 20:
            cr = _context5.sent;
            log = findLog(cr, pspContract["interface"], "UninstallationPrepared");
            if (log) {
              _context5.next = 24;
              break;
            }
            throw new PluginUninstallationPreparationError();
          case 24:
            parsedLog = pspContract["interface"].parseLog(log);
            permissions = parsedLog.args["permissions"];
            if (permissions) {
              _context5.next = 28;
              break;
            }
            throw new PluginUninstallationPreparationError();
          case 28:
            _context5.next = 30;
            return {
              key: PrepareUninstallationSteps.DONE,
              permissions: permissions.map(function (permission) {
                return {
                  operation: permission.operation,
                  where: permission.where,
                  who: permission.who,
                  permissionId: permission.permissionId
                };
              }),
              pluginRepo: selectedInstallation.appliedPreparation.pluginRepo.id,
              pluginAddress: params.pluginAddress,
              versionTag: {
                build: selectedInstallation.appliedVersion.build,
                release: selectedInstallation.appliedVersion.release.release
              }
            };
          case 30:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }))();
  }
  /**
   * Checks whether a role is granted by the current DAO's ACL settings
   *
   * @param {HasPermissionParams} params
   * @return {*}  {Promise<boolean>}
   * @memberof ClientMethods
   */;
  _proto.hasPermission =
  /*#__PURE__*/
  function () {
    var _hasPermission = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(params) {
      var signer, daoInstance;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            signer = this.web3.getConnectedSigner(); // connect to the managing dao
            daoInstance = DAO__factory.connect(params.daoAddressOrEns, signer);
            return _context6.abrupt("return", daoInstance.hasPermission(params.where, params.who, id(params.permission), params.data || new Uint8Array([])));
          case 3:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function hasPermission(_x2) {
      return _hasPermission.apply(this, arguments);
    }
    return hasPermission;
  }()
  /**
   * Retrieves metadata for DAO with given identifier (address or ens domain)
   *
   * @param {string} daoAddressOrEns
   * @return {*}  {(Promise<DaoDetails | null>)}
   * @memberof ClientMethods
   */
  ;
  _proto.getDao =
  /*#__PURE__*/
  function () {
    var _getDao = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(daoAddressOrEns) {
      var address, provider, resolvedAddress, query, params, name, _yield$this$graphql$r, dao, metadataCid, metadataString, metadata;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            address = daoAddressOrEns;
            if (isAddress(address)) {
              _context7.next = 19;
              break;
            }
            _context7.next = 4;
            return this.web3.ensureOnline();
          case 4:
            provider = this.web3.getProvider();
            if (provider) {
              _context7.next = 7;
              break;
            }
            throw new NoProviderError();
          case 7:
            _context7.prev = 7;
            _context7.next = 10;
            return provider.resolveName(address);
          case 10:
            resolvedAddress = _context7.sent;
            if (resolvedAddress) {
              _context7.next = 13;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 13:
            address = resolvedAddress.toLowerCase();
            _context7.next = 19;
            break;
          case 16:
            _context7.prev = 16;
            _context7.t0 = _context7["catch"](7);
            throw new InvalidAddressOrEnsError(_context7.t0);
          case 19:
            query = QueryDao;
            params = {
              address: address
            };
            name = "DAO";
            _context7.next = 24;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 24:
            _yield$this$graphql$r = _context7.sent;
            dao = _yield$this$graphql$r.dao;
            if (dao) {
              _context7.next = 30;
              break;
            }
            return _context7.abrupt("return", null);
          case 30:
            if (dao.metadata) {
              _context7.next = 32;
              break;
            }
            return _context7.abrupt("return", toDaoDetails(dao, EMPTY_DAO_METADATA_LINK));
          case 32:
            _context7.prev = 32;
            metadataCid = resolveIpfsCid(dao.metadata);
            _context7.next = 36;
            return this.ipfs.fetchString(metadataCid);
          case 36:
            metadataString = _context7.sent;
            metadata = JSON.parse(metadataString);
            return _context7.abrupt("return", toDaoDetails(dao, metadata));
          case 41:
            _context7.prev = 41;
            _context7.t1 = _context7["catch"](32);
            if (!(_context7.t1 instanceof InvalidCidError)) {
              _context7.next = 45;
              break;
            }
            return _context7.abrupt("return", toDaoDetails(dao, UNSUPPORTED_DAO_METADATA_LINK));
          case 45:
            return _context7.abrupt("return", toDaoDetails(dao, UNAVAILABLE_DAO_METADATA));
          case 46:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this, [[7, 16], [32, 41]]);
    }));
    function getDao(_x3) {
      return _getDao.apply(this, arguments);
    }
    return getDao;
  }()
  /**
   * Retrieves metadata for DAO with given identifier (address or ens domain)
   *
   * @param {DaoQueryParams} {
   *     limit = 10,
   *     skip = 0,
   *     direction = SortDirection.ASC,
   *     sortBy = DaoSortBy.CREATED_AT,
   *   }
   * @return {*}  {Promise<DaoListItem[]>}
   * @memberof ClientMethods
   */
  ;
  _proto.getDaos =
  /*#__PURE__*/
  function () {
    var _getDaos = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_ref) {
      var _this5 = this;
      var _ref$limit, limit, _ref$skip, skip, _ref$direction, direction, _ref$sortBy, sortBy, query, params, name, _yield$this$graphql$r2, daos;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? 10 : _ref$limit, _ref$skip = _ref.skip, skip = _ref$skip === void 0 ? 0 : _ref$skip, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? SortDirection.ASC : _ref$direction, _ref$sortBy = _ref.sortBy, sortBy = _ref$sortBy === void 0 ? DaoSortBy.CREATED_AT : _ref$sortBy;
            query = QueryDaos;
            params = {
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "DAOs";
            _context9.next = 6;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 6:
            _yield$this$graphql$r2 = _context9.sent;
            daos = _yield$this$graphql$r2.daos;
            return _context9.abrupt("return", Promise.all(daos.map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(dao) {
                var metadataCid, stringMetadata, metadata;
                return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                  while (1) switch (_context8.prev = _context8.next) {
                    case 0:
                      if (dao.metadata) {
                        _context8.next = 2;
                        break;
                      }
                      return _context8.abrupt("return", toDaoListItem(dao, EMPTY_DAO_METADATA_LINK));
                    case 2:
                      _context8.prev = 2;
                      metadataCid = resolveIpfsCid(dao.metadata);
                      _context8.next = 6;
                      return _this5.ipfs.fetchString(metadataCid);
                    case 6:
                      stringMetadata = _context8.sent;
                      metadata = JSON.parse(stringMetadata);
                      return _context8.abrupt("return", toDaoListItem(dao, metadata));
                    case 11:
                      _context8.prev = 11;
                      _context8.t0 = _context8["catch"](2);
                      if (!(_context8.t0 instanceof InvalidCidError)) {
                        _context8.next = 15;
                        break;
                      }
                      return _context8.abrupt("return", toDaoListItem(dao, UNSUPPORTED_DAO_METADATA_LINK));
                    case 15:
                      return _context8.abrupt("return", toDaoListItem(dao, UNAVAILABLE_DAO_METADATA));
                    case 16:
                    case "end":
                      return _context8.stop();
                  }
                }, _callee8, null, [[2, 11]]);
              }));
              return function (_x5) {
                return _ref2.apply(this, arguments);
              };
            }())));
          case 9:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this);
    }));
    function getDaos(_x4) {
      return _getDaos.apply(this, arguments);
    }
    return getDaos;
  }()
  /**
   * Retrieves the asset balances of the given DAO, by default, ETH, DAI, USDC and USDT on Mainnet
   *
   * @param {DaoBalancesQueryParams} {
   *     daoAddressOrEns,
   *     limit = 10,
   *     skip = 0,
   *     direction = SortDirection.ASC,
   *     sortBy = AssetBalanceSortBy.LAST_UPDATED,
   *   }
   * @return {*}  {(Promise<AssetBalance[] | null>)}
   * @memberof ClientMethods
   */
  ;
  _proto.getDaoBalances =
  /*#__PURE__*/
  function () {
    var _getDaoBalances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_ref3) {
      var daoAddressOrEns, _ref3$limit, limit, _ref3$skip, skip, _ref3$direction, direction, _ref3$sortBy, sortBy, where, address, provider, resolvedAddress, query, params, name, _yield$this$graphql$r3, tokenBalances;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            daoAddressOrEns = _ref3.daoAddressOrEns, _ref3$limit = _ref3.limit, limit = _ref3$limit === void 0 ? 10 : _ref3$limit, _ref3$skip = _ref3.skip, skip = _ref3$skip === void 0 ? 0 : _ref3$skip, _ref3$direction = _ref3.direction, direction = _ref3$direction === void 0 ? SortDirection.ASC : _ref3$direction, _ref3$sortBy = _ref3.sortBy, sortBy = _ref3$sortBy === void 0 ? AssetBalanceSortBy.LAST_UPDATED : _ref3$sortBy;
            where = {};
            address = daoAddressOrEns;
            if (!address) {
              _context10.next = 17;
              break;
            }
            if (isAddress(address)) {
              _context10.next = 16;
              break;
            }
            _context10.next = 7;
            return this.web3.ensureOnline();
          case 7:
            provider = this.web3.getProvider();
            if (provider) {
              _context10.next = 10;
              break;
            }
            throw new NoProviderError();
          case 10:
            _context10.next = 12;
            return provider.resolveName(address);
          case 12:
            resolvedAddress = _context10.sent;
            if (resolvedAddress) {
              _context10.next = 15;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 15:
            address = resolvedAddress;
          case 16:
            where = {
              dao: address.toLowerCase()
            };
          case 17:
            query = QueryTokenBalances;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "dao balances";
            _context10.next = 22;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 22:
            _yield$this$graphql$r3 = _context10.sent;
            tokenBalances = _yield$this$graphql$r3.tokenBalances;
            if (!(tokenBalances.length === 0)) {
              _context10.next = 26;
              break;
            }
            return _context10.abrupt("return", []);
          case 26:
            return _context10.abrupt("return", Promise.all(tokenBalances.map(function (balance) {
              return toAssetBalance(balance);
            })));
          case 27:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this);
    }));
    function getDaoBalances(_x6) {
      return _getDaoBalances.apply(this, arguments);
    }
    return getDaoBalances;
  }()
  /**
   * Retrieves the list of asset transfers to and from the given DAO (by default, from ETH, DAI, USDC and USDT, on Mainnet)
   *
   * @param {TransferQueryParams} {
   *     daoAddressOrEns,
   *     type,
   *     limit = 10,
   *     skip = 0,
   *     direction = SortDirection.ASC,
   *     sortBy = TransferSortBy.CREATED_AT,
   *   }
   * @return {*}  {(Promise<Transfer[] | null>)}
   * @memberof ClientMethods
   */
  ;
  _proto.getDaoTransfers =
  /*#__PURE__*/
  function () {
    var _getDaoTransfers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(_ref4) {
      var daoAddressOrEns, type, _ref4$limit, limit, _ref4$skip, skip, _ref4$direction, direction, _ref4$sortBy, sortBy, where, address, provider, resolvedAddress, query, params, name, _yield$this$graphql$r4, tokenTransfers;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            daoAddressOrEns = _ref4.daoAddressOrEns, type = _ref4.type, _ref4$limit = _ref4.limit, limit = _ref4$limit === void 0 ? 10 : _ref4$limit, _ref4$skip = _ref4.skip, skip = _ref4$skip === void 0 ? 0 : _ref4$skip, _ref4$direction = _ref4.direction, direction = _ref4$direction === void 0 ? SortDirection.ASC : _ref4$direction, _ref4$sortBy = _ref4.sortBy, sortBy = _ref4$sortBy === void 0 ? TransferSortBy.CREATED_AT : _ref4$sortBy;
            where = {};
            address = daoAddressOrEns;
            if (!address) {
              _context11.next = 23;
              break;
            }
            if (isAddress(address)) {
              _context11.next = 22;
              break;
            }
            _context11.next = 7;
            return this.web3.ensureOnline();
          case 7:
            provider = this.web3.getProvider();
            if (provider) {
              _context11.next = 10;
              break;
            }
            throw new NoProviderError();
          case 10:
            _context11.prev = 10;
            _context11.next = 13;
            return provider.resolveName(address);
          case 13:
            resolvedAddress = _context11.sent;
            if (resolvedAddress) {
              _context11.next = 16;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 16:
            address = resolvedAddress;
            _context11.next = 22;
            break;
          case 19:
            _context11.prev = 19;
            _context11.t0 = _context11["catch"](10);
            throw new InvalidAddressOrEnsError(_context11.t0);
          case 22:
            where = {
              dao: address.toLowerCase()
            };
          case 23:
            if (type) {
              where = _extends({}, where, {
                type: SubgraphTransferTypeMap.get(type)
              });
            }
            query = QueryTokenTransfers;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "dao transfers";
            _context11.next = 29;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 29:
            _yield$this$graphql$r4 = _context11.sent;
            tokenTransfers = _yield$this$graphql$r4.tokenTransfers;
            if (tokenTransfers) {
              _context11.next = 33;
              break;
            }
            return _context11.abrupt("return", null);
          case 33:
            return _context11.abrupt("return", Promise.all(tokenTransfers.map(function (transfer) {
              return toTokenTransfer(transfer);
            })));
          case 34:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this, [[10, 19]]);
    }));
    function getDaoTransfers(_x7) {
      return _getDaoTransfers.apply(this, arguments);
    }
    return getDaoTransfers;
  }()
  /**
   * Retrieves the list of plugins available on the PluginRegistry
   *
   * @param {PluginQueryParams} {
   *     limit = 10,
   *     skip = 0,
   *     direction = SortDirection.ASC,
   *     sortBy = PluginSortBy.SUBDOMAIN,
   *     subdomain
   *   }
   * @return {*}  {(Promise<PluginRepo[] | null>)}
   * @memberof ClientMethods
   */
  ;
  _proto.getPlugins =
  /*#__PURE__*/
  function () {
    var _getPlugins = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(_temp) {
      var _this6 = this;
      var _ref5, _ref5$limit, limit, _ref5$skip, skip, _ref5$direction, direction, _ref5$sortBy, sortBy, subdomain, where, query, params, name, _yield$this$graphql$r5, pluginRepos;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            _ref5 = _temp === void 0 ? {} : _temp, _ref5$limit = _ref5.limit, limit = _ref5$limit === void 0 ? 10 : _ref5$limit, _ref5$skip = _ref5.skip, skip = _ref5$skip === void 0 ? 0 : _ref5$skip, _ref5$direction = _ref5.direction, direction = _ref5$direction === void 0 ? SortDirection.ASC : _ref5$direction, _ref5$sortBy = _ref5.sortBy, sortBy = _ref5$sortBy === void 0 ? PluginSortBy.SUBDOMAIN : _ref5$sortBy, subdomain = _ref5.subdomain;
            where = {};
            if (subdomain) {
              where = {
                subdomain_contains_nocase: subdomain
              };
            }
            query = QueryPlugins;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "plugin repos";
            _context13.next = 8;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 8:
            _yield$this$graphql$r5 = _context13.sent;
            pluginRepos = _yield$this$graphql$r5.pluginRepos;
            return _context13.abrupt("return", Promise.all(pluginRepos.map( /*#__PURE__*/function () {
              var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(pluginRepo) {
                var pluginRepoReleases, _iterator2, _step2, release, metadata, metadataCid, stringMetadata, resolvedMetadata;
                return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                  while (1) switch (_context12.prev = _context12.next) {
                    case 0:
                      pluginRepoReleases = [];
                      _iterator2 = _createForOfIteratorHelperLoose(pluginRepo.releases);
                    case 2:
                      if ((_step2 = _iterator2()).done) {
                        _context12.next = 25;
                        break;
                      }
                      release = _step2.value;
                      metadata = void 0;
                      if (release.metadata) {
                        _context12.next = 9;
                        break;
                      }
                      metadata = EMPTY_RELEASE_METADATA_LINK;
                      _context12.next = 22;
                      break;
                    case 9:
                      _context12.prev = 9;
                      metadataCid = resolveIpfsCid(release.metadata);
                      _context12.next = 13;
                      return _this6.ipfs.fetchString(metadataCid);
                    case 13:
                      stringMetadata = _context12.sent;
                      resolvedMetadata = JSON.parse(stringMetadata);
                      metadata = resolvedMetadata;
                      _context12.next = 22;
                      break;
                    case 18:
                      _context12.prev = 18;
                      _context12.t0 = _context12["catch"](9);
                      metadata = UNAVAILABLE_RELEASE_METADATA;
                      if (_context12.t0 instanceof InvalidCidError) {
                        metadata = UNSUPPORTED_RELEASE_METADATA_LINK;
                      }
                    case 22:
                      pluginRepoReleases = [].concat(pluginRepoReleases, [toPluginRepoRelease(release, metadata)]);
                    case 23:
                      _context12.next = 2;
                      break;
                    case 25:
                      return _context12.abrupt("return", toPluginRepoListItem(pluginRepo, pluginRepoReleases));
                    case 26:
                    case "end":
                      return _context12.stop();
                  }
                }, _callee12, null, [[9, 18]]);
              }));
              return function (_x9) {
                return _ref6.apply(this, arguments);
              };
            }())));
          case 11:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this);
    }));
    function getPlugins(_x8) {
      return _getPlugins.apply(this, arguments);
    }
    return getPlugins;
  }()
  /**
   * Get plugin details given an address, release and build
   *
   * @param {string} pluginAddress
   * @return {*}  {Promise<PluginRepo>}
   * @memberof ClientMethods
   */
  ;
  _proto.getPlugin =
  /*#__PURE__*/
  function () {
    var _getPlugin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(pluginAddress) {
      var name, query, _yield$this$graphql$r6, pluginRepo, releaseMetadata, metadataCid, stringMetadata, resolvedMetadata, buildMetadata, _metadataCid, _stringMetadata, _resolvedMetadata;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            name = "plugin version";
            query = QueryPlugin;
            _context14.next = 4;
            return this.graphql.request({
              query: query,
              params: {
                id: pluginAddress
              },
              name: name
            });
          case 4:
            _yield$this$graphql$r6 = _context14.sent;
            pluginRepo = _yield$this$graphql$r6.pluginRepo;
            if (pluginRepo.releases[0].metadata) {
              _context14.next = 10;
              break;
            }
            releaseMetadata = EMPTY_RELEASE_METADATA_LINK;
            _context14.next = 23;
            break;
          case 10:
            _context14.prev = 10;
            metadataCid = resolveIpfsCid(pluginRepo.releases[0].metadata);
            _context14.next = 14;
            return this.ipfs.fetchString(metadataCid);
          case 14:
            stringMetadata = _context14.sent;
            resolvedMetadata = JSON.parse(stringMetadata);
            releaseMetadata = resolvedMetadata;
            _context14.next = 23;
            break;
          case 19:
            _context14.prev = 19;
            _context14.t0 = _context14["catch"](10);
            releaseMetadata = UNAVAILABLE_RELEASE_METADATA;
            if (_context14.t0 instanceof InvalidCidError) {
              releaseMetadata = UNSUPPORTED_RELEASE_METADATA_LINK;
            }
          case 23:
            if (pluginRepo.releases[0].builds[0].metadata) {
              _context14.next = 27;
              break;
            }
            buildMetadata = EMPTY_BUILD_METADATA_LINK;
            _context14.next = 40;
            break;
          case 27:
            _context14.prev = 27;
            _metadataCid = resolveIpfsCid(pluginRepo.releases[0].builds[0].metadata);
            _context14.next = 31;
            return this.ipfs.fetchString(_metadataCid);
          case 31:
            _stringMetadata = _context14.sent;
            _resolvedMetadata = JSON.parse(_stringMetadata);
            buildMetadata = _resolvedMetadata;
            _context14.next = 40;
            break;
          case 36:
            _context14.prev = 36;
            _context14.t1 = _context14["catch"](27);
            buildMetadata = UNAVAILABLE_BUILD_METADATA;
            if (_context14.t1 instanceof InvalidCidError) {
              buildMetadata = UNSUPPORTED_BUILD_METADATA_LINK;
            }
          case 40:
            return _context14.abrupt("return", toPluginRepo(pluginRepo, releaseMetadata, buildMetadata));
          case 41:
          case "end":
            return _context14.stop();
        }
      }, _callee14, this, [[10, 19], [27, 36]]);
    }));
    function getPlugin(_x10) {
      return _getPlugin.apply(this, arguments);
    }
    return getPlugin;
  }();
  return ClientMethods;
}(ClientCore);

/**
 * Encoding module the SDK Generic Client
 */
var ClientEncoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(ClientEncoding, _ClientCore);
  function ClientEncoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = ClientEncoding.prototype;
  /**
   * @param {string} daoAddress
   * @param {ApplyInstallationParams} params
   * @return {*}  {DaoAction}
   * @memberof ClientEncoding
   */
  _proto.applyInstallationAction = function applyInstallationAction(daoAddress, params) {
    if (!isAddress(daoAddress)) {
      throw new InvalidAddressError();
    }
    var network = this.web3.getNetworkName();
    var pspInterface = PluginSetupProcessor__factory.createInterface();
    var args = applyInstallatonParamsToContract(params);
    var hexBytes = pspInterface.encodeFunctionData("applyInstallation", [daoAddress, args]);
    // Grant ROOT_PERMISION in the DAO to the PSP
    var grantAction = this.grantAction(daoAddress, {
      where: daoAddress,
      who: LIVE_CONTRACTS[network].pluginSetupProcessor,
      permission: Permissions.ROOT_PERMISSION
    });
    // Revoke ROOT_PERMISION in the DAO to the PSP
    var revokeAction = this.revokeAction(daoAddress, {
      where: daoAddress,
      who: LIVE_CONTRACTS[network].pluginSetupProcessor,
      permission: Permissions.ROOT_PERMISSION
    });
    return [grantAction, {
      to: LIVE_CONTRACTS[network].pluginSetupProcessor,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    }, revokeAction];
  };
  _proto.applyUninstallationAction = function applyUninstallationAction(daoAddress, params) {
    var network = this.web3.getNetworkName();
    var pspInterface = PluginSetupProcessor__factory.createInterface();
    var args = applyUninstallationParamsToContract(params);
    var hexBytes = pspInterface.encodeFunctionData("applyUninstallation", [daoAddress, args]);
    // Grant ROOT_PERMISION in the DAO to the PSP
    var grantAction = this.grantAction(daoAddress, {
      where: daoAddress,
      who: LIVE_CONTRACTS[network].pluginSetupProcessor,
      permission: Permissions.ROOT_PERMISSION
    });
    // Revoke ROOT_PERMISION in the DAO to the PSP
    var revokeAction = this.revokeAction(daoAddress, {
      where: daoAddress,
      who: LIVE_CONTRACTS[network].pluginSetupProcessor,
      permission: Permissions.ROOT_PERMISSION
    });
    return [grantAction, {
      to: LIVE_CONTRACTS[network].pluginSetupProcessor,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    }, revokeAction];
  }
  /**
   * Computes the payload to be given when creating a proposal that grants a permission within a DAO
   *
   * @param {string} daoAddress
   * @param {GrantPermissionParams} params
   * @return {*}  {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.grantAction = function grantAction(daoAddress, params) {
    var where = params.where,
      who = params.who;
    if (!isAddress(where) || !isAddress(who) || !isAddress(daoAddress)) {
      throw new InvalidAddressError();
    }
    var daoInterface = DAO__factory.createInterface();
    var args = permissionParamsToContract({
      who: who,
      where: where,
      permission: params.permission
    });
    // get hex bytes
    var hexBytes = daoInterface.encodeFunctionData("grant", args);
    return {
      to: daoAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that grants a permission within a DAO given a certain condition
   *
   * @param {string} daoAddress
   * @param {GrantPermissionWithConditionParams} params
   * @return {*}  {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.grantWithConditionAction = function grantWithConditionAction(daoAddress, params) {
    var where = params.where,
      who = params.who;
    if (!isAddress(where) || !isAddress(who) || !isAddress(daoAddress)) {
      throw new InvalidAddressError();
    }
    var daoInterface = DAO__factory.createInterface();
    var args = permissionWithConditionParamsToContract({
      who: who,
      where: where,
      permission: params.permission,
      condition: params.condition
    });
    // get hex bytes
    var hexBytes = daoInterface.encodeFunctionData("grantWithCondition", args);
    return {
      to: daoAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that revokes a permission within a DAO
   *
   * @param {string} daoAddress
   * @param {RevokePermissionParams} params
   * @return {*}  {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.revokeAction = function revokeAction(daoAddress, params) {
    var where = params.where,
      who = params.who;
    if (!isAddress(where) || !isAddress(who) || !isAddress(daoAddress)) {
      throw new InvalidAddressError();
    }
    var daoInterface = DAO__factory.createInterface();
    var args = permissionParamsToContract({
      who: who,
      where: where,
      permission: params.permission
    });
    // get hex bytes
    var hexBytes = daoInterface.encodeFunctionData("revoke", args);
    return {
      to: daoAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that withdraws ether from the DAO
   *
   * @param {string} recipientAddressOrEns
   * @param {WithdrawParams} value
   * @return {*}  {Promise<DaoAction>}
   * @memberof ClientEncoding
   */;
  _proto.withdrawAction =
  /*#__PURE__*/
  function () {
    var _withdrawAction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var to, _this$web3$getSigner, resolvedAddress, iface, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            to = params.recipientAddressOrEns;
            if (isAddress(params.recipientAddressOrEns)) {
              _context.next = 8;
              break;
            }
            _context.next = 4;
            return (_this$web3$getSigner = this.web3.getSigner()) == null ? void 0 : _this$web3$getSigner.resolveName(params.recipientAddressOrEns);
          case 4:
            resolvedAddress = _context.sent;
            if (resolvedAddress) {
              _context.next = 7;
              break;
            }
            throw new Error("invalid ens");
          case 7:
            to = resolvedAddress;
          case 8:
            _context.t0 = params.type;
            _context.next = _context.t0 === TokenType.NATIVE ? 11 : _context.t0 === TokenType.ERC20 ? 12 : 17;
            break;
          case 11:
            return _context.abrupt("return", {
              to: to,
              value: params.amount,
              data: new Uint8Array()
            });
          case 12:
            if (params.tokenAddress) {
              _context.next = 14;
              break;
            }
            throw new Error("Empty token contract address");
          case 14:
            iface = new Contract(params.tokenAddress, erc20ContractAbi)["interface"];
            data = iface.encodeFunctionData("transfer", [params.recipientAddressOrEns, params.amount]);
            return _context.abrupt("return", {
              to: params.tokenAddress,
              value: BigInt(0),
              data: hexToBytes(data)
            });
          case 17:
            throw new Error("Unsupported token type");
          case 18:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function withdrawAction(_x) {
      return _withdrawAction.apply(this, arguments);
    }
    return withdrawAction;
  }()
  /**
   * Computes the payload to be given when creating a proposal that updates the metadata the DAO
   *
   * @param {string} daoAddressOrEns
   * @param {DaoMetadata} params
   * @return {*}  {Promise<DaoAction>}
   * @memberof ClientEncoding
   */
  ;
  _proto.updateDaoMetadataAction =
  /*#__PURE__*/
  function () {
    var _updateDaoMetadataAction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(daoAddressOrEns, metadataUri) {
      var address, _this$web3$getSigner2, resolvedAddress, daoInterface, args, hexBytes;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            address = daoAddressOrEns;
            if (isAddress(daoAddressOrEns)) {
              _context2.next = 8;
              break;
            }
            _context2.next = 4;
            return (_this$web3$getSigner2 = this.web3.getSigner()) == null ? void 0 : _this$web3$getSigner2.resolveName(daoAddressOrEns);
          case 4:
            resolvedAddress = _context2.sent;
            if (resolvedAddress) {
              _context2.next = 7;
              break;
            }
            throw new Error("Invalid ENS");
          case 7:
            address = resolvedAddress;
          case 8:
            // upload metadata to IPFS
            daoInterface = DAO__factory.createInterface();
            args = toUtf8Bytes(metadataUri);
            hexBytes = daoInterface.encodeFunctionData("setMetadata", [args]);
            return _context2.abrupt("return", {
              to: address,
              value: BigInt(0),
              data: hexToBytes(hexBytes)
            });
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function updateDaoMetadataAction(_x2, _x3) {
      return _updateDaoMetadataAction.apply(this, arguments);
    }
    return updateDaoMetadataAction;
  }()
  /**
   * Computes the payload to be given when creating a proposal that sets the dao uri
   *
   * @param {string} daoAddressOrEns
   * @param {string} daoUri
   * @return {*}  {DaoAction}
   * @memberof ClientEncoding
   */
  ;
  _proto.setDaoUriAction = function setDaoUriAction(daoAddressOrEns, daoUri) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = daoInterface.encodeFunctionData("setDaoURI", [daoUri]);
    return {
      to: daoAddressOrEns,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that registers a new standard callback
   *
   * @param {string} daoAddressOrEns
   * @param {string} daoUri
   * @return {*}  {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.registerStandardCallbackAction = function registerStandardCallbackAction(daoAddressOrEns, params) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = daoInterface.encodeFunctionData("registerStandardCallback", [params.interfaceId, params.callbackSelector, params.magicNumber]);
    return {
      to: daoAddressOrEns,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that sets the signature validator
   *
   * @param {string} daoAddressOrEns
   * @param {string} signatureValidator
   * @return {*}  {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.setSignatureValidatorAction = function setSignatureValidatorAction(daoAddressOrEns, signatureValidator) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = daoInterface.encodeFunctionData("setSignatureValidator", [signatureValidator]);
    return {
      to: daoAddressOrEns,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that sets a new implementation for the proxy
   *
   * @param {string} daoAddressOrEns
   * @param {string} implementationAddress
   * @return {*}  {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.upgradeToAction = function upgradeToAction(daoAddressOrEns, implementationAddress) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = daoInterface.encodeFunctionData("upgradeTo", [implementationAddress]);
    return {
      to: daoAddressOrEns,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that sets a new implementation for the proxy and calls the callback function with the specified data
   *
   * @param {string} daoAddressOrEns
   * @param {UpgradeToAndCallParams} params
   * @return {*}  {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.upgradeToAndCallAction = function upgradeToAndCallAction(daoAddressOrEns, params) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = daoInterface.encodeFunctionData("upgradeToAndCall", [params.implementationAddress, params.data]);
    return {
      to: daoAddressOrEns,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  };
  return ClientEncoding;
}(ClientCore);

/**
 * Estimation module the SDK Generic Client
 */
var ClientEstimation = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(ClientEstimation, _ClientCore);
  function ClientEstimation() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = ClientEstimation.prototype;
  /**
   * Estimates the gas fee of creating a DAO
   *
   * @param {CreateDaoParams} _params
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof ClientEstimation
   */
  _proto.createDao =
  /*#__PURE__*/
  function () {
    var _createDao = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var signer, daoInstance, pluginInstallationData, _iterator, _step, plugin, repo, currentRelease, latestVersion, gasEstimation;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            if (!(params.ensSubdomain && !params.ensSubdomain.match(/^[a-z0-9\-]+$/))) {
              _context.next = 3;
              break;
            }
            throw new Error("Invalid subdomain format: use a-z, 0-9 and -");
          case 3:
            daoInstance = DAOFactory__factory.connect(this.web3.getDaoFactoryAddress(), signer);
            pluginInstallationData = [];
            _iterator = _createForOfIteratorHelperLoose(params.plugins);
          case 6:
            if ((_step = _iterator()).done) {
              _context.next = 18;
              break;
            }
            plugin = _step.value;
            repo = PluginRepo__factory.connect(plugin.id, signer);
            _context.next = 11;
            return repo.latestRelease();
          case 11:
            currentRelease = _context.sent;
            _context.next = 14;
            return repo["getLatestVersion(uint8)"](currentRelease);
          case 14:
            latestVersion = _context.sent;
            pluginInstallationData.push({
              pluginSetupRef: {
                pluginSetupRepo: repo.address,
                versionTag: latestVersion.tag
              },
              data: plugin.data
            });
          case 16:
            _context.next = 6;
            break;
          case 18:
            _context.next = 20;
            return daoInstance.estimateGas.createDao({
              subdomain: params.ensSubdomain,
              metadata: toUtf8Bytes(params.metadataUri),
              daoURI: params.daoUri || "",
              trustedForwarder: params.trustedForwarder || AddressZero
            }, pluginInstallationData);
          case 20:
            gasEstimation = _context.sent;
            return _context.abrupt("return", this.web3.getApproximateGasFee(gasEstimation.toBigInt()));
          case 22:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function createDao(_x) {
      return _createDao.apply(this, arguments);
    }
    return createDao;
  }()
  /**
   * Estimates the gas fee of depositing ether or an ERC20 token into the DAO
   * This does not estimate the gas cost of updating the allowance of an ERC20 token
   *
   * @param {DepositParams} params
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof ClientEstimation
   */
  ;
  _proto.deposit = function deposit(params) {
    var _this = this;
    var signer = this.web3.getConnectedSigner();
    if (params.type !== TokenType.NATIVE && params.type !== TokenType.ERC20) {
      throw new DepositNativeTokenError();
    }
    var _unwrapDepositParams = unwrapDepositParams(params),
      daoAddress = _unwrapDepositParams[0],
      amount = _unwrapDepositParams[1],
      tokenAddress = _unwrapDepositParams[2],
      reference = _unwrapDepositParams[3];
    var daoInstance = DAO__factory.connect(daoAddress, signer);
    var override = {};
    if (tokenAddress === AddressZero) {
      override.value = amount;
    }
    return daoInstance.estimateGas.deposit(tokenAddress, amount, reference, override).then(function (gasLimit) {
      return _this.web3.getApproximateGasFee(gasLimit.toBigInt());
    });
  }
  /**
   * Estimates the gas fee of updating the allowance of an ERC20 token
   *
   * @param {SetAllowanceParams} _params
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof ClientEstimation
   */;
  _proto.setAllowance =
  /*#__PURE__*/
  function () {
    var _setAllowance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var _this2 = this;
      var signer, daoAddress, provider, resolvedAddress, contract;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            signer = this.web3.getConnectedSigner(); // resolve ens
            daoAddress = params.spender;
            if (isAddress(daoAddress)) {
              _context2.next = 14;
              break;
            }
            _context2.next = 5;
            return this.web3.ensureOnline();
          case 5:
            provider = this.web3.getProvider();
            if (provider) {
              _context2.next = 8;
              break;
            }
            throw new NoProviderError();
          case 8:
            _context2.next = 10;
            return provider.resolveName(daoAddress);
          case 10:
            resolvedAddress = _context2.sent;
            if (resolvedAddress) {
              _context2.next = 13;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 13:
            daoAddress = resolvedAddress;
          case 14:
            contract = new Contract(params.tokenAddress, erc20ContractAbi, signer);
            return _context2.abrupt("return", contract.estimateGas.approve(daoAddress, params.amount).then(function (gasLimit) {
              return _this2.web3.getApproximateGasFee(gasLimit.toBigInt());
            }));
          case 16:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function setAllowance(_x2) {
      return _setAllowance.apply(this, arguments);
    }
    return setAllowance;
  }();
  return ClientEstimation;
}(ClientCore);

/**
 * Decoding module the SDK Generic Client
 */
var ClientDecoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(ClientDecoding, _ClientCore);
  function ClientDecoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = ClientDecoding.prototype;
  /**
   * @param {data} Uint8Array
   * @return {*}  {DecodedApplyInstallationParams}
   * @memberof ClientDecoding
   */
  _proto.applyInstallationAction = function applyInstallationAction(data) {
    var pspInterface = PluginSetupProcessor__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = pspInterface.getFunction("applyInstallation");
    var result = pspInterface.decodeFunctionData(expectedFunction, hexBytes);
    return applyInstallatonParamsFromContract(result);
  }
  /**
   * @param {data} Uint8Array
   * @return {*}  {DecodedApplyInstallationParams}
   * @memberof ClientDecoding
   */;
  _proto.applyUninstallationAction = function applyUninstallationAction(data) {
    var pspInterface = PluginSetupProcessor__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = pspInterface.getFunction("applyUninstallation");
    var result = pspInterface.decodeFunctionData(expectedFunction, hexBytes);
    return applyInstallatonParamsFromContract(result);
  }
  /**
   * Decodes the permission parameters from an encoded grant action
   *
   * @param {Uint8Array} data
   * @return {*}  {GrantPermissionDecodedParams}
   * @memberof ClientDecoding
   */;
  _proto.grantAction = function grantAction(data) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("grant");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return permissionParamsFromContract(result);
  }
  /**
   * Decodes the grant permission with condition parameters from an encoded grant with condition action
   *
   * @param {Uint8Array} data
   * @return {*}  {GrantPermissionWithConditionParams}
   * @memberof ClientDecoding
   */;
  _proto.grantWithConditionAction = function grantWithConditionAction(data) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("grantWithCondition");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return permissionParamsWitConditionFromContract(result);
  }
  /**
   * Decodes the permission parameters from an encoded revoke action
   *
   * @param {Uint8Array} data
   * @return {*}  {RevokePermissionDecodedParams}
   * @memberof ClientDecoding
   */;
  _proto.revokeAction = function revokeAction(data) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("revoke");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return permissionParamsFromContract(result);
  }
  /**
   * Decodes the withdraw parameters from an encoded withdraw action
   *
   * @param {Uint8Array} data
   * @return {*}  {WithdrawParams}
   * @memberof ClientDecoding
   */;
  _proto.withdrawAction = function withdrawAction(to, value, data) {
    // Native
    if (!(data != null && data.length)) {
      return {
        type: TokenType.NATIVE,
        recipientAddressOrEns: to,
        amount: value
      };
    }
    // ERC20 and other
    var abiObjects = [{
      tokenStandard: TokenType.ERC20,
      abi: erc20ContractAbi
    }];
    for (var _i = 0, _abiObjects = abiObjects; _i < _abiObjects.length; _i++) {
      var abiObject = _abiObjects[_i];
      var hexBytes = bytesToHex(data);
      var iface = new Contract(AddressZero, abiObject.abi)["interface"];
      var expectedFunction = iface.getFunction("transfer");
      var result = iface.decodeFunctionData(expectedFunction, hexBytes);
      return withdrawParamsFromContract(to, value, result, abiObject.tokenStandard);
    }
    throw new Error("The received action is not recognized");
  }
  /**
   * Decodes a dao metadata ipfs uri from an encoded update metadata action
   *
   * @param {Uint8Array} data
   * @return {*}  {string}
   * @memberof ClientDecoding
   */;
  _proto.updateDaoMetadataRawAction = function updateDaoMetadataRawAction(data) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("setMetadata");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    var metadataUri = toUtf8String(result[0]);
    resolveIpfsCid(metadataUri);
    return metadataUri;
  }
  /**
   * Decodes a dao metadata from an encoded update metadata raw action
   *
   * @param {Uint8Array} data
   * @return {*}  {Promise<DaoMetadata>}
   * @memberof ClientDecoding
   */;
  _proto.updateDaoMetadataAction =
  /*#__PURE__*/
  function () {
    var _updateDaoMetadataAction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data) {
      var daoInterface, hexBytes, expectedFunction, result, metadataUri, ipfsCid, stringMetadata;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            daoInterface = DAO__factory.createInterface();
            hexBytes = bytesToHex(data);
            expectedFunction = daoInterface.getFunction("setMetadata");
            result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
            metadataUri = toUtf8String(result[0]);
            ipfsCid = resolveIpfsCid(metadataUri);
            _context.prev = 6;
            _context.next = 9;
            return this.ipfs.fetchString(ipfsCid);
          case 9:
            stringMetadata = _context.sent;
            return _context.abrupt("return", JSON.parse(stringMetadata));
          case 13:
            _context.prev = 13;
            _context.t0 = _context["catch"](6);
            throw new Error("Error reading data from IPFS");
          case 16:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[6, 13]]);
    }));
    function updateDaoMetadataAction(_x) {
      return _updateDaoMetadataAction.apply(this, arguments);
    }
    return updateDaoMetadataAction;
  }()
  /**
   * Decodes the daoUri from a setDaoUriAction
   *
   * @param {Uint8Array} data
   * @return {*}  {string}
   * @memberof ClientDecoding
   */
  ;
  _proto.setDaoUriAction = function setDaoUriAction(data) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("setDaoURI");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return result[0];
  }
  /**
   * Decodes the RegisterStandardCallbackParams from a registerStandardCallbackAction
   *
   * @param {Uint8Array} data
   * @return {*}  {RegisterStandardCallbackParams}
   * @memberof ClientDecoding
   */;
  _proto.registerStandardCallbackAction = function registerStandardCallbackAction(data) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("registerStandardCallback");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return {
      interfaceId: result[0],
      callbackSelector: result[1],
      magicNumber: result[2]
    };
  }
  /**
   * Decodes the implementation address from an encoded upgradeToAction
   *
   * @param {Uint8Array} data
   * @return {*}  {string}
   * @memberof ClientDecoding
   */;
  _proto.setSignatureValidatorAction = function setSignatureValidatorAction(data) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("setSignatureValidator");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return result[0];
  };
  _proto.upgradeToAction = function upgradeToAction(data) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("upgradeTo");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return result[0];
  }
  /**
   * Decodes upgradeToAndCallback params from an upgradeToAndCallAction
   *
   * @param {Uint8Array} data
   * @return {*}  {UpgradeToAndCallParams}
   * @memberof ClientDecoding
   */;
  _proto.upgradeToAndCallAction = function upgradeToAndCallAction(data) {
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("upgradeToAndCall");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return {
      implementationAddress: result[0],
      data: hexToBytes(result[1])
    };
  }
  /**
   * Returns the decoded function info given the encoded data of an action
   *
   * @param {Uint8Array} data
   * @return {*}  {(InterfaceParams | null)}
   * @memberof ClientDecoding
   */;
  _proto.findInterface = function findInterface(data) {
    try {
      var func = getFunctionFragment(data, AVAILABLE_FUNCTION_SIGNATURES);
      return {
        id: func.format("minimal"),
        functionName: func.name,
        hash: bytesToHex(data).substring(0, 10)
      };
    } catch (_unused2) {
      return null;
    }
  };
  return ClientDecoding;
}(ClientCore);

/**
 * Provider a generic client with high level methods to manage and interact with DAO's
 */
var Client = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(Client, _ClientCore);
  function Client(context) {
    var _this;
    _this = _ClientCore.call(this, context) || this;
    _this.methods = new ClientMethods(context);
    _this.encoding = new ClientEncoding(context);
    _this.decoding = new ClientDecoding(context);
    _this.estimation = new ClientEstimation(context);
    return _this;
  }
  return Client;
}(ClientCore);

var _templateObject$5;
var QueryAddresslistVotingMembers = /*#__PURE__*/gql(_templateObject$5 || (_templateObject$5 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery AddresslistVotingMembers($address: ID!) {\n    addresslistVotingPlugin(id: $address){\n        members {\n            address\n        }\n    }\n}\n"])));

var _templateObject$6, _templateObject2$2;
var QueryAddresslistVotingProposal = /*#__PURE__*/gql(_templateObject$6 || (_templateObject$6 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery AddresslistVotingProposal($proposalId: ID!) {\n  addresslistVotingProposal(id: $proposalId){\n    id\n    dao {\n      id\n      subdomain\n    }\n    creator\n    metadata\n    createdAt\n    creationBlockNumber\n    executionDate\n    executionBlockNumber\n    actions {\n      to\n      value\n      data\n    }\n    yes\n    no\n    abstain\n    votingMode\n    supportThreshold\n    startDate\n    endDate\n    executed\n    earlyExecutable\n    potentiallyExecutable\n    executionTxHash\n    voters{\n      voter{\n        address\n      }\n      voteOption\n      voteReplaced\n    }\n    totalVotingPower\n    minVotingPower\n  }\n}\n"])));
var QueryAddresslistVotingProposals = /*#__PURE__*/gql(_templateObject2$2 || (_templateObject2$2 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery AddresslistVotingProposals($where: AddresslistVotingProposal_filter!, $limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: AddresslistVotingProposal_orderBy!) {\n  addresslistVotingProposals(where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy){\n    id\n    dao {\n      id\n      subdomain\n    }\n    creator\n    metadata\n    yes\n    no\n    abstain\n    startDate\n    endDate\n    executed\n    earlyExecutable\n    potentiallyExecutable\n    voters{\n      voter{\n        address\n      }\n      voteOption\n      voteReplaced\n    }\n  }\n}\n"])));

var _templateObject$7;
var QueryAddresslistVotingSettings = /*#__PURE__*/gql(_templateObject$7 || (_templateObject$7 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery AddresslistVotingSettings($address: ID!) {\n  addresslistVotingPlugin(id: $address){\n    minDuration\n    minProposerVotingPower\n    minParticipation\n    supportThreshold\n    votingMode\n  }\n}\n"])));

function toAddresslistVotingProposal(proposal, metadata) {
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  var creationDate = new Date(parseInt(proposal.createdAt) * 1000);
  var executionDate = proposal.executionDate ? new Date(parseInt(proposal.executionDate) * 1000) : null;
  return {
    id: getCompactProposalId(proposal.id),
    dao: {
      address: proposal.dao.id,
      name: proposal.dao.subdomain
    },
    creatorAddress: proposal.creator,
    metadata: {
      title: metadata.title,
      summary: metadata.summary,
      description: metadata.description,
      resources: metadata.resources,
      media: metadata.media
    },
    startDate: startDate,
    endDate: endDate,
    creationDate: creationDate,
    executionTxHash: proposal.executionTxHash || null,
    creationBlockNumber: parseInt(proposal.creationBlockNumber),
    executionDate: executionDate,
    executionBlockNumber: parseInt(proposal.executionBlockNumber) || null,
    actions: proposal.actions.map(function (action) {
      return {
        data: hexToBytes(action.data),
        to: action.to,
        value: BigInt(action.value)
      };
    }),
    status: computeProposalStatus(proposal),
    result: {
      yes: proposal.yes ? parseInt(proposal.yes) : 0,
      no: proposal.no ? parseInt(proposal.no) : 0,
      abstain: proposal.abstain ? parseInt(proposal.abstain) : 0
    },
    settings: {
      supportThreshold: decodeRatio(BigInt(proposal.supportThreshold), 6),
      minParticipation: decodeRatio(BigInt(proposal.minVotingPower) * BigInt(1000000) / BigInt(proposal.totalVotingPower), 6),
      duration: parseInt(proposal.endDate) - parseInt(proposal.startDate)
    },
    totalVotingWeight: parseInt(proposal.totalVotingPower),
    votes: proposal.voters.map(function (voter) {
      return {
        voteReplaced: voter.voteReplaced,
        address: voter.voter.address,
        vote: SubgraphVoteValuesMap.get(voter.voteOption)
      };
    })
  };
}
function toAddresslistVotingProposalListItem(proposal, metadata) {
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  return {
    id: getCompactProposalId(proposal.id),
    dao: {
      address: proposal.dao.id,
      name: proposal.dao.subdomain
    },
    creatorAddress: proposal.creator,
    metadata: {
      title: metadata.title,
      summary: metadata.summary
    },
    startDate: startDate,
    endDate: endDate,
    status: computeProposalStatus(proposal),
    result: {
      yes: proposal.yes ? parseInt(proposal.yes) : 0,
      no: proposal.no ? parseInt(proposal.no) : 0,
      abstain: proposal.abstain ? parseInt(proposal.abstain) : 0
    },
    votes: proposal.voters.map(function (voter) {
      return {
        voteReplaced: voter.voteReplaced,
        address: voter.voter.address,
        vote: SubgraphVoteValuesMap.get(voter.voteOption)
      };
    })
  };
}

/**
 * Encoding module for the SDK AddressList Client
 */
var AddresslistVotingClientEncoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(AddresslistVotingClientEncoding, _ClientCore);
  function AddresslistVotingClientEncoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  /**
   * Computes the parameters to be given when creating the DAO,
   * so that the plugin is configured
   *
   * @param {AddresslistVotingPluginInstall} params
   * @param {Networkish} network
   * @return {*}  {PluginInstallItem}
   * @memberof AddresslistVotingClientEncoding
   */
  AddresslistVotingClientEncoding.getPluginInstallItem = function getPluginInstallItem(params, network) {
    var networkName = getNetwork(network).name;
    if (!SupportedNetworksArray.includes(networkName)) {
      throw new UnsupportedNetworkError(networkName);
    }
    var _votingSettingsToCont = votingSettingsToContract(params.votingSettings),
      votingMode = _votingSettingsToCont.votingMode,
      supportThreshold = _votingSettingsToCont.supportThreshold,
      minParticipation = _votingSettingsToCont.minParticipation,
      minDuration = _votingSettingsToCont.minDuration,
      minProposerVotingPower = _votingSettingsToCont.minProposerVotingPower;
    var hexBytes = defaultAbiCoder.encode(["tuple(uint8 votingMode, uint64 supportThreshold, uint64 minParticipation, uint64 minDuration, uint256 minProposerVotingPower) votingSettings", "address[] members"], [[votingMode, supportThreshold, minParticipation, minDuration, minProposerVotingPower], params.addresses]);
    return {
      id: LIVE_CONTRACTS[networkName].addresslistVotingRepo,
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that updates the governance configuration
   *
   * @param {string} pluginAddress
   * @param {VotingSettings} params
   * @return {*}  {DaoAction}
   * @memberof AddresslistVotingClientEncoding
   */;
  var _proto = AddresslistVotingClientEncoding.prototype;
  _proto.updatePluginSettingsAction = function updatePluginSettingsAction(pluginAddress, params) {
    if (!isAddress(pluginAddress)) {
      throw new InvalidAddressError();
    }
    // TODO: check if to and value are correct
    return {
      to: pluginAddress,
      value: BigInt(0),
      data: encodeUpdateVotingSettingsAction(params)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that adds addresses to address list
   *
   * @param {string} pluginAddress
   * @param {string[]} members
   * @return {*}  {DaoAction}
   * @memberof AddresslistVotingClientEncoding
   */;
  _proto.addMembersAction = function addMembersAction(pluginAddress, members) {
    if (!isAddress(pluginAddress)) {
      throw new InvalidAddressError();
    }
    for (var _iterator = _createForOfIteratorHelperLoose(members), _step; !(_step = _iterator()).done;) {
      var member = _step.value;
      if (!isAddress(member)) {
        throw new InvalidAddressError();
      }
    }
    var votingInterface = AddresslistVoting__factory.createInterface();
    // get hex bytes
    var hexBytes = votingInterface.encodeFunctionData("addAddresses", [members]);
    return {
      to: pluginAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that removes addresses from the address list
   *
   * @param {string} pluginAddress
   * @param {string[]} members
   * @return {*}  {DaoAction}
   * @memberof AddresslistVotingClientEncoding
   */;
  _proto.removeMembersAction = function removeMembersAction(pluginAddress, members) {
    if (!isAddress(pluginAddress)) {
      throw new InvalidAddressError();
    }
    for (var _iterator2 = _createForOfIteratorHelperLoose(members), _step2; !(_step2 = _iterator2()).done;) {
      var member = _step2.value;
      if (!isAddress(member)) {
        throw new InvalidAddressError();
      }
    }
    var votingInterface = AddresslistVoting__factory.createInterface();
    // get hex bytes
    var hexBytes = votingInterface.encodeFunctionData("removeAddresses", [members]);
    return {
      to: pluginAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  };
  return AddresslistVotingClientEncoding;
}(ClientCore);

/**
 * Methods module the SDK Address List Client
 */
var AddresslistVotingClientMethods = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(AddresslistVotingClientMethods, _ClientCore);
  function AddresslistVotingClientMethods() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = AddresslistVotingClientMethods.prototype;
  /**
   * Creates a new proposal on the given AddressList plugin contract
   *
   * @param {CreateMajorityVotingProposalParams} params
   * @return {*}  {AsyncGenerator<ProposalCreationStepValue>}
   * @memberof AddresslistVotingClientMethods
   */
  _proto.createProposal = function createProposal(params) {
    var _this = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _params$failSafeActio, _params$actions, _params$startDate, _params$endDate;
      var signer, addresslistContract, allowFailureMap, startTimestamp, endTimestamp, tx, receipt, addresslistContractInterface, log, parsedLog, proposalId;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            signer = _this.web3.getConnectedSigner();
            addresslistContract = AddresslistVoting__factory.connect(params.pluginAddress, signer);
            if (!((_params$failSafeActio = params.failSafeActions) != null && _params$failSafeActio.length && params.failSafeActions.length !== ((_params$actions = params.actions) == null ? void 0 : _params$actions.length))) {
              _context.next = 4;
              break;
            }
            throw new Error("Size mismatch: actions and failSafeActions should match");
          case 4:
            allowFailureMap = boolArrayToBitmap(params.failSafeActions);
            startTimestamp = ((_params$startDate = params.startDate) == null ? void 0 : _params$startDate.getTime()) || 0;
            endTimestamp = ((_params$endDate = params.endDate) == null ? void 0 : _params$endDate.getTime()) || 0;
            _context.next = 9;
            return _awaitAsyncGenerator(addresslistContract.createProposal(toUtf8Bytes(params.metadataUri), params.actions || [], allowFailureMap, Math.round(startTimestamp / 1000), Math.round(endTimestamp / 1000), params.creatorVote || 0, params.executeOnPass || false));
          case 9:
            tx = _context.sent;
            _context.next = 12;
            return {
              key: ProposalCreationSteps.CREATING,
              txHash: tx.hash
            };
          case 12:
            _context.next = 14;
            return _awaitAsyncGenerator(tx.wait());
          case 14:
            receipt = _context.sent;
            addresslistContractInterface = AddresslistVoting__factory.createInterface();
            log = findLog(receipt, addresslistContractInterface, "ProposalCreated");
            if (log) {
              _context.next = 19;
              break;
            }
            throw new ProposalCreationError();
          case 19:
            parsedLog = addresslistContractInterface.parseLog(log);
            proposalId = parsedLog.args["proposalId"];
            if (proposalId) {
              _context.next = 23;
              break;
            }
            throw new ProposalCreationError();
          case 23:
            _context.next = 25;
            return {
              key: ProposalCreationSteps.DONE,
              proposalId: encodeProposalId(params.pluginAddress, Number(proposalId))
            };
          case 25:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  }
  /**
   * Pins a metadata object into IPFS and retruns the generated hash
   *
   * @param {ProposalMetadata} params
   * @return {*}  {Promise<string>}
   * @memberof ClientMethods
   */;
  _proto.pinMetadata =
  /*#__PURE__*/
  function () {
    var _pinMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var cid;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.ipfs.add(JSON.stringify(params));
          case 3:
            cid = _context2.sent;
            _context2.next = 6;
            return this.ipfs.pin(cid);
          case 6:
            return _context2.abrupt("return", "ipfs://" + cid);
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](0);
            throw new IpfsPinError(_context2.t0);
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[0, 9]]);
    }));
    function pinMetadata(_x) {
      return _pinMetadata.apply(this, arguments);
    }
    return pinMetadata;
  }()
  /**
   * Cast a vote on the given proposal using the client's wallet. Depending on the proposal settings, an affirmative vote may execute the proposal's actions on the DAO.
   *
   * @param {VoteProposalParams} params
   * @return {*}  {AsyncGenerator<VoteProposalStepValue>}
   * @memberof AddresslistVotingClientMethods
   */
  ;
  _proto.voteProposal = function voteProposal(params) {
    var _this2 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var signer, _decodeProposalId, pluginAddress, id, addresslistContract, tx;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            signer = _this2.web3.getConnectedSigner();
            _decodeProposalId = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId.pluginAddress, id = _decodeProposalId.id;
            addresslistContract = AddresslistVoting__factory.connect(pluginAddress, signer);
            _context3.next = 5;
            return _awaitAsyncGenerator(addresslistContract.vote(id, params.vote, false));
          case 5:
            tx = _context3.sent;
            _context3.next = 8;
            return {
              key: VoteProposalStep.VOTING,
              txHash: tx.hash
            };
          case 8:
            _context3.next = 10;
            return _awaitAsyncGenerator(tx.wait());
          case 10:
            _context3.next = 12;
            return {
              key: VoteProposalStep.DONE
            };
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }))();
  }
  /**
   * Executes the given proposal, provided that it has already passed
   *
   * @param {string} proposalId
   * @return {*}  {AsyncGenerator<ExecuteProposalStepValue>}
   * @memberof AddresslistVotingClientMethods
   */;
  _proto.executeProposal = function executeProposal(proposalId) {
    var _this3 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var signer, _decodeProposalId2, pluginAddress, id, addresslistContract, tx;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            signer = _this3.web3.getConnectedSigner();
            _decodeProposalId2 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId2.pluginAddress, id = _decodeProposalId2.id;
            addresslistContract = AddresslistVoting__factory.connect(pluginAddress, signer);
            _context4.next = 5;
            return _awaitAsyncGenerator(addresslistContract.execute(id));
          case 5:
            tx = _context4.sent;
            _context4.next = 8;
            return {
              key: ExecuteProposalStep.EXECUTING,
              txHash: tx.hash
            };
          case 8:
            _context4.next = 10;
            return _awaitAsyncGenerator(tx.wait());
          case 10:
            _context4.next = 12;
            return {
              key: ExecuteProposalStep.DONE
            };
          case 12:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }))();
  }
  /**
   * Prepares the installation of a token voting plugin in a given dao
   *
   * @param {AddresslistVotingPluginPrepareInstallationParams} params
   * @return {*}  {AsyncGenerator<PrepareInstallationStepValue>}
   * @memberof MultisigClientMethods
   */;
  _proto.prepareInstallation = function prepareInstallation(params) {
    var _this4 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var signer, networkName, pspContract, addresslistVotingRepoContract, versionTag, latestVersion, addresslistVotingPluginInstallItem, tx, receipt, pspContractInterface, log, parsedLog, pluginAddress, preparedSetupData;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            signer = _this4.web3.getConnectedSigner();
            networkName = _this4.web3.getNetworkName(); // connect to psp contract
            pspContract = PluginSetupProcessor__factory.connect(LIVE_CONTRACTS[networkName].pluginSetupProcessor, signer); // connect to plugin repo
            addresslistVotingRepoContract = PluginRepo__factory.connect(LIVE_CONTRACTS[networkName].addresslistVotingRepo, signer); // use specified version or latest
            versionTag = params.versionTag;
            if (params.versionTag) {
              _context5.next = 10;
              break;
            }
            _context5.next = 8;
            return _awaitAsyncGenerator(addresslistVotingRepoContract["getLatestVersion(address)"](LIVE_CONTRACTS[networkName].addresslistVotingSetup));
          case 8:
            latestVersion = _context5.sent;
            versionTag = {
              build: latestVersion.tag.build,
              release: latestVersion.tag.release
            };
          case 10:
            // get install data
            addresslistVotingPluginInstallItem = AddresslistVotingClientEncoding.getPluginInstallItem(params.settings, networkName); // execute prepareInstallation
            _context5.next = 13;
            return _awaitAsyncGenerator(pspContract.prepareInstallation(params.daoAddressOrEns, {
              pluginSetupRef: {
                pluginSetupRepo: LIVE_CONTRACTS[networkName].addresslistVotingRepo,
                versionTag: versionTag
              },
              data: addresslistVotingPluginInstallItem.data
            }));
          case 13:
            tx = _context5.sent;
            _context5.next = 16;
            return {
              key: PrepareInstallationStep.PREPARING,
              txHash: tx.hash
            };
          case 16:
            _context5.next = 18;
            return _awaitAsyncGenerator(tx.wait());
          case 18:
            receipt = _context5.sent;
            pspContractInterface = PluginSetupProcessor__factory.createInterface();
            log = findLog(receipt, pspContractInterface, "InstallationPrepared");
            if (log) {
              _context5.next = 23;
              break;
            }
            throw new ProposalCreationError();
          case 23:
            parsedLog = pspContractInterface.parseLog(log);
            pluginAddress = parsedLog.args["plugin"];
            preparedSetupData = parsedLog.args["preparedSetupData"];
            if (pluginAddress || preparedSetupData) {
              _context5.next = 28;
              break;
            }
            throw new PluginInstallationPreparationError();
          case 28:
            _context5.next = 30;
            return {
              key: PrepareInstallationStep.DONE,
              pluginAddress: pluginAddress,
              pluginRepo: LIVE_CONTRACTS[networkName].addresslistVotingRepo,
              versionTag: versionTag,
              permissions: preparedSetupData.permissions,
              helpers: preparedSetupData.helpers
            };
          case 30:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }))();
  }
  /**
   * Checks if an user can vote in a proposal
   *
   * @param {CanVoteParams} params
   * @return {*}  {Promise<boolean>}
   * @memberof AddresslistVotingClientMethods
   */;
  _proto.canVote =
  /*#__PURE__*/
  function () {
    var _canVote = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(params) {
      var signer, _decodeProposalId3, pluginAddress, id, addresslistContract;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _decodeProposalId3 = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId3.pluginAddress, id = _decodeProposalId3.id;
            addresslistContract = AddresslistVoting__factory.connect(pluginAddress, signer);
            return _context6.abrupt("return", addresslistContract.callStatic.canVote(id, params.voterAddressOrEns, params.vote));
          case 4:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function canVote(_x2) {
      return _canVote.apply(this, arguments);
    }
    return canVote;
  }()
  /**
   * Checks whether the current proposal can be executed
   *
   * @param {string} proposalId
   * @return {*}  {Promise<boolean>}
   * @memberof AddresslistVotingClientMethods
   */
  ;
  _proto.canExecute =
  /*#__PURE__*/
  function () {
    var _canExecute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(proposalId) {
      var signer, _decodeProposalId4, pluginAddress, id, addresslistContract;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _decodeProposalId4 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId4.pluginAddress, id = _decodeProposalId4.id;
            addresslistContract = AddresslistVoting__factory.connect(pluginAddress, signer);
            return _context7.abrupt("return", addresslistContract.canExecute(id));
          case 4:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
    function canExecute(_x3) {
      return _canExecute.apply(this, arguments);
    }
    return canExecute;
  }()
  /**
   * Returns the list of wallet addresses with signing capabilities on the plugin
   *
   * @async
   * @param {string} pluginAddress
   * @return {*}  {Promise<string[]>}
   * @memberof AddresslistVotingClientMethods
   */
  ;
  _proto.getMembers =
  /*#__PURE__*/
  function () {
    var _getMembers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(pluginAddress) {
      var query, params, name, _yield$this$graphql$r, addresslistVotingPlugin;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            if (isAddress(pluginAddress)) {
              _context8.next = 2;
              break;
            }
            throw new InvalidAddressError();
          case 2:
            query = QueryAddresslistVotingMembers;
            params = {
              address: pluginAddress.toLowerCase()
            };
            name = "AddresslistVotingVoting members";
            _context8.next = 7;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 7:
            _yield$this$graphql$r = _context8.sent;
            addresslistVotingPlugin = _yield$this$graphql$r.addresslistVotingPlugin;
            return _context8.abrupt("return", addresslistVotingPlugin.members.map(function (member) {
              return member.address;
            }));
          case 10:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this);
    }));
    function getMembers(_x4) {
      return _getMembers.apply(this, arguments);
    }
    return getMembers;
  }()
  /**
   * Returns the details of the given proposal
   *
   * @param {string} proposalId
   * @return {*}  {(Promise<AddresslistVotingProposal | null>)}
   * @memberof AddresslistVotingClientMethods
   */
  ;
  _proto.getProposal =
  /*#__PURE__*/
  function () {
    var _getProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(proposalId) {
      var extendedProposalId, query, params, name, _yield$this$graphql$r2, addresslistVotingProposal, metadataCid, metadataString, metadata;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            if (isProposalId(proposalId)) {
              _context9.next = 2;
              break;
            }
            throw new InvalidProposalIdError();
          case 2:
            extendedProposalId = getExtendedProposalId(proposalId);
            query = QueryAddresslistVotingProposal;
            params = {
              proposalId: extendedProposalId
            };
            name = "AddresslistVoting proposal";
            _context9.next = 8;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 8:
            _yield$this$graphql$r2 = _context9.sent;
            addresslistVotingProposal = _yield$this$graphql$r2.addresslistVotingProposal;
            if (addresslistVotingProposal) {
              _context9.next = 14;
              break;
            }
            return _context9.abrupt("return", null);
          case 14:
            if (addresslistVotingProposal.metadata) {
              _context9.next = 16;
              break;
            }
            return _context9.abrupt("return", toAddresslistVotingProposal(addresslistVotingProposal, EMPTY_PROPOSAL_METADATA_LINK));
          case 16:
            _context9.prev = 16;
            metadataCid = resolveIpfsCid(addresslistVotingProposal.metadata);
            _context9.next = 20;
            return this.ipfs.fetchString(metadataCid);
          case 20:
            metadataString = _context9.sent;
            metadata = JSON.parse(metadataString);
            return _context9.abrupt("return", toAddresslistVotingProposal(addresslistVotingProposal, metadata));
          case 25:
            _context9.prev = 25;
            _context9.t0 = _context9["catch"](16);
            if (!(_context9.t0 instanceof InvalidCidError)) {
              _context9.next = 29;
              break;
            }
            return _context9.abrupt("return", toAddresslistVotingProposal(addresslistVotingProposal, UNSUPPORTED_PROPOSAL_METADATA_LINK));
          case 29:
            return _context9.abrupt("return", toAddresslistVotingProposal(addresslistVotingProposal, UNAVAILABLE_PROPOSAL_METADATA));
          case 30:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this, [[16, 25]]);
    }));
    function getProposal(_x5) {
      return _getProposal.apply(this, arguments);
    }
    return getProposal;
  }()
  /**
   * Returns a list of proposals on the Plugin, filtered by the given criteria
   *
   * @param {ProposalQueryParams} {
   *       daoAddressOrEns,
   *       limit = 10,
   *       status,
   *       skip = 0,
   *       direction = SortDirection.ASC,
   *       sortBy = ProposalSortBy.CREATED_AT,
   *     }
   * @return {*}  {Promise<AddresslistVotingProposalListItem[]>}
   * @memberof AddresslistVotingClientMethods
   */
  ;
  _proto.getProposals =
  /*#__PURE__*/
  function () {
    var _getProposals = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(_ref) {
      var _this5 = this;
      var daoAddressOrEns, _ref$limit, limit, status, _ref$skip, skip, _ref$direction, direction, _ref$sortBy, sortBy, where, address, provider, resolvedAddress, query, params, name, _yield$this$graphql$r3, addresslistVotingProposals;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            daoAddressOrEns = _ref.daoAddressOrEns, _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? 10 : _ref$limit, status = _ref.status, _ref$skip = _ref.skip, skip = _ref$skip === void 0 ? 0 : _ref$skip, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? SortDirection.ASC : _ref$direction, _ref$sortBy = _ref.sortBy, sortBy = _ref$sortBy === void 0 ? ProposalSortBy.CREATED_AT : _ref$sortBy;
            where = {};
            address = daoAddressOrEns;
            if (!address) {
              _context11.next = 23;
              break;
            }
            if (isAddress(address)) {
              _context11.next = 22;
              break;
            }
            _context11.next = 7;
            return this.web3.ensureOnline();
          case 7:
            provider = this.web3.getProvider();
            if (provider) {
              _context11.next = 10;
              break;
            }
            throw new NoProviderError();
          case 10:
            _context11.prev = 10;
            _context11.next = 13;
            return provider.resolveName(address);
          case 13:
            resolvedAddress = _context11.sent;
            if (resolvedAddress) {
              _context11.next = 16;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 16:
            address = resolvedAddress;
            _context11.next = 22;
            break;
          case 19:
            _context11.prev = 19;
            _context11.t0 = _context11["catch"](10);
            throw new InvalidAddressOrEnsError();
          case 22:
            where = {
              dao: address.toLowerCase()
            };
          case 23:
            if (status) {
              where = _extends({}, where, computeProposalStatusFilter(status));
            }
            query = QueryAddresslistVotingProposals;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "AddresslistVoting proposals";
            _context11.next = 29;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 29:
            _yield$this$graphql$r3 = _context11.sent;
            addresslistVotingProposals = _yield$this$graphql$r3.addresslistVotingProposals;
            return _context11.abrupt("return", Promise.all(addresslistVotingProposals.map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(proposal) {
                var metadataCid, stringMetadata, metadata;
                return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                  while (1) switch (_context10.prev = _context10.next) {
                    case 0:
                      if (proposal.metadata) {
                        _context10.next = 2;
                        break;
                      }
                      return _context10.abrupt("return", toAddresslistVotingProposalListItem(proposal, EMPTY_PROPOSAL_METADATA_LINK));
                    case 2:
                      _context10.prev = 2;
                      metadataCid = resolveIpfsCid(proposal.metadata);
                      _context10.next = 6;
                      return _this5.ipfs.fetchString(metadataCid);
                    case 6:
                      stringMetadata = _context10.sent;
                      metadata = JSON.parse(stringMetadata);
                      return _context10.abrupt("return", toAddresslistVotingProposalListItem(proposal, metadata));
                    case 11:
                      _context10.prev = 11;
                      _context10.t0 = _context10["catch"](2);
                      if (!(_context10.t0 instanceof InvalidCidError)) {
                        _context10.next = 15;
                        break;
                      }
                      return _context10.abrupt("return", toAddresslistVotingProposalListItem(proposal, UNSUPPORTED_PROPOSAL_METADATA_LINK));
                    case 15:
                      return _context10.abrupt("return", toAddresslistVotingProposalListItem(proposal, UNAVAILABLE_PROPOSAL_METADATA));
                    case 16:
                    case "end":
                      return _context10.stop();
                  }
                }, _callee10, null, [[2, 11]]);
              }));
              return function (_x7) {
                return _ref2.apply(this, arguments);
              };
            }())));
          case 32:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this, [[10, 19]]);
    }));
    function getProposals(_x6) {
      return _getProposals.apply(this, arguments);
    }
    return getProposals;
  }()
  /**
   * Returns the settings of a plugin given the address of the plugin instance
   *
   * @param {string} pluginAddress
   * @return {*}  {(Promise<VotingSettings | null>)}
   * @memberof AddresslistVotingClientMethods
   */
  ;
  _proto.getVotingSettings =
  /*#__PURE__*/
  function () {
    var _getVotingSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(pluginAddress) {
      var query, params, name, _yield$this$graphql$r4, addresslistVotingPlugin;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            if (isAddress(pluginAddress)) {
              _context12.next = 2;
              break;
            }
            throw new InvalidAddressError();
          case 2:
            query = QueryAddresslistVotingSettings;
            params = {
              address: pluginAddress.toLowerCase()
            };
            name = "AddresslistVoting settings";
            _context12.next = 7;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 7:
            _yield$this$graphql$r4 = _context12.sent;
            addresslistVotingPlugin = _yield$this$graphql$r4.addresslistVotingPlugin;
            if (addresslistVotingPlugin) {
              _context12.next = 11;
              break;
            }
            return _context12.abrupt("return", null);
          case 11:
            return _context12.abrupt("return", {
              minDuration: parseInt(addresslistVotingPlugin.minDuration),
              supportThreshold: decodeRatio(BigInt(addresslistVotingPlugin.supportThreshold), 6),
              minParticipation: decodeRatio(BigInt(addresslistVotingPlugin.minParticipation), 6),
              minProposerVotingPower: BigInt(addresslistVotingPlugin.minProposerVotingPower),
              votingMode: addresslistVotingPlugin.votingMode
            });
          case 12:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this);
    }));
    function getVotingSettings(_x8) {
      return _getVotingSettings.apply(this, arguments);
    }
    return getVotingSettings;
  }();
  return AddresslistVotingClientMethods;
}(ClientCore);

var AVAILABLE_FUNCTION_SIGNATURES$1 = [/*#__PURE__*/MajorityVotingBase__factory.createInterface().getFunction("updateVotingSettings").format("minimal"), /*#__PURE__*/AddresslistVoting__factory.createInterface().getFunction("addAddresses").format("minimal"), /*#__PURE__*/AddresslistVoting__factory.createInterface().getFunction("removeAddresses").format("minimal")];

/**
 * Decoding module for the SDK AddressList Client
 */
var AddresslistVotingClientDecoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(AddresslistVotingClientDecoding, _ClientCore);
  function AddresslistVotingClientDecoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = AddresslistVotingClientDecoding.prototype;
  /**
   * Decodes a dao metadata from an encoded update metadata action
   *
   * @param {Uint8Array} data
   * @return {*}  {VotingSettings}
   * @memberof AddresslistVotingClientDecoding
   */
  _proto.updatePluginSettingsAction = function updatePluginSettingsAction(data) {
    return decodeUpdatePluginSettingsAction(data);
  }
  /**
   * Decodes a list of addresses from an encoded add members action
   *
   * @param {Uint8Array} data
   * @return {*}  {string[]}
   * @memberof AddresslistVotingClientDecoding
   */;
  _proto.addMembersAction = function addMembersAction(data) {
    var votingInterface = AddresslistVoting__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedfunction = votingInterface.getFunction("addAddresses");
    var result = votingInterface.decodeFunctionData(expectedfunction, hexBytes);
    return result[0];
  }
  /**
   * Decodes a list of addresses from an encoded remove members action
   *
   * @param {Uint8Array} data
   * @return {*}  {string[]}
   * @memberof AddresslistVotingClientDecoding
   */;
  _proto.removeMembersAction = function removeMembersAction(data) {
    var votingInterface = AddresslistVoting__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedfunction = votingInterface.getFunction("removeAddresses");
    var result = votingInterface.decodeFunctionData(expectedfunction, hexBytes);
    return result[0];
  }
  /**
   * Returns the decoded function info given the encoded data of an action
   *
   * @param {Uint8Array} data
   * @return {*}  {(InterfaceParams | null)}
   * @memberof AddresslistVotingClientDecoding
   */;
  _proto.findInterface = function findInterface(data) {
    try {
      var func = getFunctionFragment(data, AVAILABLE_FUNCTION_SIGNATURES$1);
      return {
        id: func.format("minimal"),
        functionName: func.name,
        hash: bytesToHex(data).substring(0, 10)
      };
    } catch (_unused) {
      return null;
    }
  };
  return AddresslistVotingClientDecoding;
}(ClientCore);

/**
 * Estimation module the SDK Address List Client
 */
var AddresslistVotingClientEstimation = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(AddresslistVotingClientEstimation, _ClientCore);
  function AddresslistVotingClientEstimation() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = AddresslistVotingClientEstimation.prototype;
  /**
   * Estimates the gas fee of creating a proposal on the plugin
   *
   * @param {CreateMajorityVotingProposalParams} params
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof AddresslistVotingClientEstimation
   */
  _proto.createProposal =
  /*#__PURE__*/
  function () {
    var _createProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var _params$failSafeActio, _params$actions, _params$startDate, _params$endDate;
      var signer, addresslistContract, allowFailureMap, startTimestamp, endTimestamp, estimatedGasFee;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            addresslistContract = AddresslistVoting__factory.connect(params.pluginAddress, signer);
            if (!((_params$failSafeActio = params.failSafeActions) != null && _params$failSafeActio.length && params.failSafeActions.length !== ((_params$actions = params.actions) == null ? void 0 : _params$actions.length))) {
              _context.next = 4;
              break;
            }
            throw new Error("Size mismatch: actions and failSafeActions should match");
          case 4:
            allowFailureMap = boolArrayToBitmap(params.failSafeActions);
            startTimestamp = ((_params$startDate = params.startDate) == null ? void 0 : _params$startDate.getTime()) || 0;
            endTimestamp = ((_params$endDate = params.endDate) == null ? void 0 : _params$endDate.getTime()) || 0;
            _context.next = 9;
            return addresslistContract.estimateGas.createProposal(toUtf8Bytes(params.metadataUri), params.actions || [], allowFailureMap, Math.round(startTimestamp / 1000), Math.round(endTimestamp / 1000), params.creatorVote || 0, params.executeOnPass || false);
          case 9:
            estimatedGasFee = _context.sent;
            return _context.abrupt("return", this.web3.getApproximateGasFee(estimatedGasFee.toBigInt()));
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function createProposal(_x) {
      return _createProposal.apply(this, arguments);
    }
    return createProposal;
  }()
  /**
   * Estimates the gas fee of casting a vote on a proposal
   *
   * @param {VoteProposalParams} params
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof AddresslistVotingClientEstimation
   */
  ;
  _proto.voteProposal =
  /*#__PURE__*/
  function () {
    var _voteProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var signer, _decodeProposalId, pluginAddress, id, addresslistContract, estimation;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _decodeProposalId = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId.pluginAddress, id = _decodeProposalId.id;
            addresslistContract = AddresslistVoting__factory.connect(pluginAddress, signer);
            _context2.next = 5;
            return addresslistContract.estimateGas.vote(id, params.vote, false);
          case 5:
            estimation = _context2.sent;
            return _context2.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function voteProposal(_x2) {
      return _voteProposal.apply(this, arguments);
    }
    return voteProposal;
  }()
  /**
   * Estimates the gas fee of executing an AddressList proposal
   *
   * @param {string} proposalId
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof AddresslistVotingClientEstimation
   */
  ;
  _proto.executeProposal =
  /*#__PURE__*/
  function () {
    var _executeProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(proposalId) {
      var signer, _decodeProposalId2, pluginAddress, id, addresslistContract, estimation;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _decodeProposalId2 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId2.pluginAddress, id = _decodeProposalId2.id;
            addresslistContract = AddresslistVoting__factory.connect(pluginAddress, signer);
            _context3.next = 5;
            return addresslistContract.estimateGas.execute(id);
          case 5:
            estimation = _context3.sent;
            return _context3.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 7:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function executeProposal(_x3) {
      return _executeProposal.apply(this, arguments);
    }
    return executeProposal;
  }();
  return AddresslistVotingClientEstimation;
}(ClientCore);

/**
 * Provider a generic client with high level methods to manage and interact an Address List Voting plugin installed in a DAO
 */
var AddresslistVotingClient = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(AddresslistVotingClient, _ClientCore);
  function AddresslistVotingClient(context) {
    var _this;
    _this = _ClientCore.call(this, context) || this;
    _this.methods = new AddresslistVotingClientMethods(context);
    _this.encoding = new AddresslistVotingClientEncoding(context);
    _this.decoding = new AddresslistVotingClientDecoding(context);
    _this.estimation = new AddresslistVotingClientEstimation(context);
    return _this;
  }
  return AddresslistVotingClient;
}(ClientCore);
AddresslistVotingClient.encoding = {
  /**
   * Computes the parameters to be given when creating the DAO,
   * so that the plugin is configured
   *
   * @param {AddresslistVotingPluginInstall} params
   * @param {Networkish} [network="mainnet"]
   * @return {*}  {PluginInstallItem}
   * @memberof AddresslistVotingClient
   */
  getPluginInstallItem: function getPluginInstallItem(params, network) {
    if (network === void 0) {
      network = "mainnet";
    }
    return AddresslistVotingClientEncoding.getPluginInstallItem(params, network);
  }
};

var WrapTokensStep;
(function (WrapTokensStep) {
  WrapTokensStep["WRAPPING"] = "wrapping";
  WrapTokensStep["DONE"] = "done";
})(WrapTokensStep || (WrapTokensStep = {}));
var UnwrapTokensStep;
(function (UnwrapTokensStep) {
  UnwrapTokensStep["UNWRAPPING"] = "unwrapping";
  UnwrapTokensStep["DONE"] = "done";
})(UnwrapTokensStep || (UnwrapTokensStep = {}));

var SubgraphTokenType;
(function (SubgraphTokenType) {
  SubgraphTokenType["ERC20"] = "ERC20Token";
  SubgraphTokenType["ERC721"] = "ERC721Token";
})(SubgraphTokenType || (SubgraphTokenType = {}));
var SubgraphContractType;
(function (SubgraphContractType) {
  SubgraphContractType["ERC20"] = "ERC20Contract";
  SubgraphContractType["ERC721"] = "ERC721Contract";
})(SubgraphContractType || (SubgraphContractType = {}));

var _templateObject$8, _templateObject2$3;
var QueryTokenVotingProposal = /*#__PURE__*/gql(_templateObject$8 || (_templateObject$8 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenVotingProposal($proposalId: ID!) {\n  tokenVotingProposal(id: $proposalId){\n    id\n    dao {\n      id\n      subdomain\n    }\n    creator\n    metadata\n    createdAt\n    creationBlockNumber\n    executionDate\n    executionBlockNumber\n    actions {\n      to\n      value\n      data\n    }\n    yes,\n    no,\n    abstain\n    votingMode\n    supportThreshold\n    startDate\n    endDate\n    executed\n    earlyExecutable\n    potentiallyExecutable\n    executionTxHash\n    voters{\n      voter{\n        address\n      }\n      voteReplaced\n      voteOption\n      votingPower\n    }\n    plugin {\n      token {\n        id\n        name\n        symbol\n        __typename\n        ...on ERC20Contract {\n          decimals\n        }\n      }\n    }\n    totalVotingPower\n    minVotingPower\n  }\n}\n"])));
var QueryTokenVotingProposals = /*#__PURE__*/gql(_templateObject2$3 || (_templateObject2$3 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenVotingProposals($where: TokenVotingProposal_filter!, $limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: TokenVotingProposal_orderBy!) {\n  tokenVotingProposals(where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy){\n    id\n    dao {\n      id\n      subdomain\n    }\n    creator\n    metadata\n    yes,\n    no,\n    abstain\n    startDate\n    endDate\n    executed\n    earlyExecutable\n    potentiallyExecutable\n    votingMode\n    supportThreshold\n    minVotingPower\n    totalVotingPower\n    voters{\n      voter{\n        address\n      }\n      voteReplaced\n      voteOption\n      votingPower\n    }\n    plugin{\n      token{\n        id\n        name\n        symbol\n        __typename\n        ...on ERC20Contract {\n          decimals\n        }\n      }\n    }\n  }\n}\n"])));

var _templateObject$9;
var QueryTokenVotingSettings = /*#__PURE__*/gql(_templateObject$9 || (_templateObject$9 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenVotingSettings($address: ID!) {\n  tokenVotingPlugin(id: $address){\n    minDuration\n    minProposerVotingPower\n    minParticipation\n    supportThreshold\n    votingMode\n  }\n}\n"])));

var _templateObject$a;
var QueryTokenVotingPlugin = /*#__PURE__*/gql(_templateObject$a || (_templateObject$a = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenVotingPlugin($address: ID!) {\n  tokenVotingPlugin(id: $address){\n    token {\n      id\n      name\n      symbol\n      __typename\n      ...on ERC20Contract {\n        decimals\n      }\n    }\n  }\n}\n"])));

var _templateObject$b;
var QueryTokenVotingMembers = /*#__PURE__*/gql(_templateObject$b || (_templateObject$b = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenVotingMembers($address: ID!) {\n    tokenVotingPlugin(id: $address){\n        members {\n            address\n            balance\n            votingPower\n            delegatee {\n                address\n            }\n            delegators {\n                address\n                balance\n            }\n        }\n    }\n}\n"])));

function toTokenVotingProposal(proposal, metadata) {
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  var creationDate = new Date(parseInt(proposal.createdAt) * 1000);
  var executionDate = proposal.executionDate ? new Date(parseInt(proposal.executionDate) * 1000) : null;
  var usedVotingWeight = BigInt(0);
  for (var _iterator = _createForOfIteratorHelperLoose(proposal.voters), _step; !(_step = _iterator()).done;) {
    var voter = _step.value;
    usedVotingWeight += BigInt(voter.votingPower);
  }
  var token = parseToken(proposal.plugin.token);
  return {
    id: getCompactProposalId(proposal.id),
    dao: {
      address: proposal.dao.id,
      name: proposal.dao.subdomain
    },
    creatorAddress: proposal.creator,
    metadata: {
      title: metadata.title,
      summary: metadata.summary,
      description: metadata.description,
      resources: metadata.resources,
      media: metadata.media
    },
    startDate: startDate,
    endDate: endDate,
    creationDate: creationDate,
    creationBlockNumber: parseInt(proposal.creationBlockNumber),
    executionDate: executionDate,
    executionBlockNumber: parseInt(proposal.executionBlockNumber) || null,
    executionTxHash: proposal.executionTxHash || null,
    actions: proposal.actions.map(function (action) {
      return {
        data: hexToBytes(action.data),
        to: action.to,
        value: BigInt(action.value)
      };
    }),
    status: computeProposalStatus(proposal),
    result: {
      yes: proposal.yes ? BigInt(proposal.yes) : BigInt(0),
      no: proposal.no ? BigInt(proposal.no) : BigInt(0),
      abstain: proposal.abstain ? BigInt(proposal.abstain) : BigInt(0)
    },
    settings: {
      supportThreshold: decodeRatio(BigInt(proposal.supportThreshold), 6),
      duration: parseInt(proposal.endDate) - parseInt(proposal.startDate),
      minParticipation: decodeRatio(BigInt(proposal.minVotingPower) * BigInt(1000000) / BigInt(proposal.totalVotingPower), 6)
    },
    token: token,
    usedVotingWeight: usedVotingWeight,
    totalVotingWeight: BigInt(proposal.totalVotingPower),
    votes: proposal.voters.map(function (voter) {
      return {
        voteReplaced: voter.voteReplaced,
        address: voter.voter.address,
        vote: SubgraphVoteValuesMap.get(voter.voteOption),
        weight: BigInt(voter.votingPower)
      };
    })
  };
}
function toTokenVotingProposalListItem(proposal, metadata) {
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  var token = parseToken(proposal.plugin.token);
  return {
    id: getCompactProposalId(proposal.id),
    dao: {
      address: proposal.dao.id,
      name: proposal.dao.subdomain
    },
    settings: {
      supportThreshold: decodeRatio(BigInt(proposal.supportThreshold), 6),
      duration: parseInt(proposal.endDate) - parseInt(proposal.startDate),
      minParticipation: decodeRatio(BigInt(proposal.minVotingPower) * BigInt(1000000) / BigInt(proposal.totalVotingPower), 6)
    },
    creatorAddress: proposal.creator,
    metadata: {
      title: metadata.title,
      summary: metadata.summary
    },
    totalVotingWeight: BigInt(proposal.totalVotingPower),
    startDate: startDate,
    endDate: endDate,
    status: computeProposalStatus(proposal),
    result: {
      yes: proposal.yes ? BigInt(proposal.yes) : BigInt(0),
      no: proposal.no ? BigInt(proposal.no) : BigInt(0),
      abstain: proposal.abstain ? BigInt(proposal.abstain) : BigInt(0)
    },
    token: token,
    votes: proposal.voters.map(function (voter) {
      return {
        voteReplaced: voter.voteReplaced,
        address: voter.voter.address,
        vote: SubgraphVoteValuesMap.get(voter.voteOption),
        weight: BigInt(voter.votingPower)
      };
    })
  };
}
function mintTokenParamsToContract(params) {
  return [params.address, BigNumber.from(params.amount)];
}
function mintTokenParamsFromContract(result) {
  return {
    address: result[0],
    amount: BigInt(result[1])
  };
}
function tokenVotingInitParamsToContract(params) {
  var token = ["", "", ""];
  var balances = [[], []];
  if (params.newToken) {
    token = [AddressZero, params.newToken.name, params.newToken.symbol];
    balances = [params.newToken.balances.map(function (balance) {
      return balance.address;
    }), params.newToken.balances.map(function (_ref) {
      var balance = _ref.balance;
      return BigNumber.from(balance);
    })];
  } else if (params.useToken) {
    var _params$useToken;
    token = [(_params$useToken = params.useToken) == null ? void 0 : _params$useToken.tokenAddress, params.useToken.wrappedToken.name, params.useToken.wrappedToken.symbol];
  }
  return [Object.values(votingSettingsToContract(params.votingSettings)), token, balances];
}
function parseToken(subgraphToken) {
  var token = null;
  if (subgraphToken.__typename === SubgraphContractType.ERC20) {
    token = {
      address: subgraphToken.id,
      symbol: subgraphToken.symbol,
      name: subgraphToken.name,
      decimals: subgraphToken.decimals,
      type: TokenType.ERC20
    };
  } else if (subgraphToken.__typename === SubgraphContractType.ERC721) {
    token = {
      address: subgraphToken.id,
      symbol: subgraphToken.symbol,
      name: subgraphToken.name,
      type: TokenType.ERC721
    };
  }
  return token;
}
function toTokenVotingMember(member) {
  return {
    address: member.address,
    votingPower: BigInt(member.votingPower),
    balance: BigInt(member.balance),
    delegatee: member.delegatee.address === member.address ? null : member.delegatee.address,
    delegators: member.delegators.filter(function (delegator) {
      return delegator.address !== member.address;
    }).map(function (delegator) {
      return {
        address: delegator.address,
        balance: BigInt(delegator.balance)
      };
    })
  };
}

/**
 * Encoding module the SDK TokenVoting Client
 */
var TokenVotingClientEncoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(TokenVotingClientEncoding, _ClientCore);
  function TokenVotingClientEncoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  /**
   * Computes the parameters to be given when creating the DAO,
   * so that the plugin is configured
   *
   * @param {TokenVotingPluginInstall} params
   * @param {Networkish} network
   * @return {*}  {PluginInstallItem}
   * @memberof TokenVotingClientEncoding
   */
  TokenVotingClientEncoding.getPluginInstallItem = function getPluginInstallItem(params, network) {
    var networkName = getNetwork(network).name;
    if (!SupportedNetworksArray.includes(networkName)) {
      throw new UnsupportedNetworkError(networkName);
    }
    var args = tokenVotingInitParamsToContract(params);
    var hexBytes = defaultAbiCoder.encode(
    // ["votingMode","supportThreshold", "minParticipation", "minDuration"], ["address","name","symbol"][ "receivers","amount"]
    ["tuple(uint8 votingMode, uint64 supportThreshold, uint64 minParticipation, uint64 minDuration, uint256 minProposerVotingPower) votingSettings", "tuple(address addr, string name, string symbol) tokenSettings", "tuple(address[] receivers, uint256[] amounts) mintSettings"], args);
    return {
      id: LIVE_CONTRACTS[networkName].tokenVotingRepo,
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that updates the governance configuration
   *
   * @param {string} pluginAddress
   * @param {VotingSettings} params
   * @return {*}  {DaoAction}
   * @memberof TokenVotingClientEncoding
   */;
  var _proto = TokenVotingClientEncoding.prototype;
  _proto.updatePluginSettingsAction = function updatePluginSettingsAction(pluginAddress, params) {
    if (!isAddress(pluginAddress)) {
      throw new Error("Invalid plugin address");
    }
    // TODO: check if to and value are correct
    return {
      to: pluginAddress,
      value: BigInt(0),
      data: encodeUpdateVotingSettingsAction(params)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that mints an amount of ERC-20 tokens to an address
   *
   * @param {string} minterAddress
   * @param {MintTokenParams} params
   * @return {*}  {DaoAction}
   * @memberof TokenVotingClientEncoding
   */;
  _proto.mintTokenAction = function mintTokenAction(minterAddress, params) {
    if (!isAddress(minterAddress) || !isAddress(params.address)) {
      throw new InvalidAddressError();
    }
    var votingInterface = IERC20MintableUpgradeable__factory.createInterface();
    var args = mintTokenParamsToContract(params);
    // get hex bytes
    var hexBytes = votingInterface.encodeFunctionData("mint", args);
    return {
      to: minterAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  };
  return TokenVotingClientEncoding;
}(ClientCore);

/**
 * Methods module the SDK TokenVoting Client
 */
var TokenVotingClientMethods = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(TokenVotingClientMethods, _ClientCore);
  function TokenVotingClientMethods() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = TokenVotingClientMethods.prototype;
  /**
   * Creates a new proposal on the given TokenVoting plugin contract
   *
   * @param {CreateMajorityVotingProposalParams} params
   * @return {*}  {AsyncGenerator<ProposalCreationStepValue>}
   * @memberof TokenVotingClient
   */
  _proto.createProposal = function createProposal(params) {
    var _this = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _params$failSafeActio, _params$actions, _params$startDate, _params$endDate;
      var signer, tokenVotingContract, allowFailureMap, startTimestamp, endTimestamp, tx, receipt, tokenVotingContractInterface, log, parsedLog, proposalId;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            signer = _this.web3.getConnectedSigner();
            tokenVotingContract = TokenVoting__factory.connect(params.pluginAddress, signer);
            if (!((_params$failSafeActio = params.failSafeActions) != null && _params$failSafeActio.length && params.failSafeActions.length !== ((_params$actions = params.actions) == null ? void 0 : _params$actions.length))) {
              _context.next = 4;
              break;
            }
            throw new Error("Size mismatch: actions and failSafeActions should match");
          case 4:
            allowFailureMap = boolArrayToBitmap(params.failSafeActions);
            startTimestamp = ((_params$startDate = params.startDate) == null ? void 0 : _params$startDate.getTime()) || 0;
            endTimestamp = ((_params$endDate = params.endDate) == null ? void 0 : _params$endDate.getTime()) || 0;
            _context.next = 9;
            return _awaitAsyncGenerator(tokenVotingContract.createProposal(toUtf8Bytes(params.metadataUri), params.actions || [], allowFailureMap, Math.round(startTimestamp / 1000), Math.round(endTimestamp / 1000), params.creatorVote || 0, params.executeOnPass || false));
          case 9:
            tx = _context.sent;
            _context.next = 12;
            return {
              key: ProposalCreationSteps.CREATING,
              txHash: tx.hash
            };
          case 12:
            _context.next = 14;
            return _awaitAsyncGenerator(tx.wait());
          case 14:
            receipt = _context.sent;
            tokenVotingContractInterface = TokenVoting__factory.createInterface();
            log = findLog(receipt, tokenVotingContractInterface, "ProposalCreated");
            if (log) {
              _context.next = 19;
              break;
            }
            throw new ProposalCreationError();
          case 19:
            parsedLog = tokenVotingContractInterface.parseLog(log);
            proposalId = parsedLog.args["proposalId"];
            if (proposalId) {
              _context.next = 23;
              break;
            }
            throw new ProposalCreationError();
          case 23:
            _context.next = 25;
            return {
              key: ProposalCreationSteps.DONE,
              proposalId: encodeProposalId(params.pluginAddress, Number(proposalId))
            };
          case 25:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  }
  /**
   * Pins a metadata object into IPFS and retruns the generated hash
   *
   * @param {ProposalMetadata} params
   * @return {*}  {Promise<string>}
   * @memberof ClientMethods
   */;
  _proto.pinMetadata =
  /*#__PURE__*/
  function () {
    var _pinMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var cid;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.ipfs.add(JSON.stringify(params));
          case 3:
            cid = _context2.sent;
            _context2.next = 6;
            return this.ipfs.pin(cid);
          case 6:
            return _context2.abrupt("return", "ipfs://" + cid);
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](0);
            throw new IpfsPinError(_context2.t0);
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[0, 9]]);
    }));
    function pinMetadata(_x) {
      return _pinMetadata.apply(this, arguments);
    }
    return pinMetadata;
  }()
  /**
   * Cast a vote on the given proposal using the client's wallet. Depending on the proposal settings, an affirmative vote may execute the proposal's actions on the DAO.
   *
   * @param {VoteProposalParams} params
   * @param {VoteValues} vote
   * @return {*}  {AsyncGenerator<VoteProposalStepValue>}
   * @memberof TokenVotingClient
   */
  ;
  _proto.voteProposal = function voteProposal(params) {
    var _this2 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var signer, _decodeProposalId, pluginAddress, id, tokenVotingContract, tx;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            signer = _this2.web3.getConnectedSigner();
            _decodeProposalId = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId.pluginAddress, id = _decodeProposalId.id;
            tokenVotingContract = TokenVoting__factory.connect(pluginAddress, signer);
            _context3.next = 5;
            return _awaitAsyncGenerator(tokenVotingContract.vote(id, params.vote, false));
          case 5:
            tx = _context3.sent;
            _context3.next = 8;
            return {
              key: VoteProposalStep.VOTING,
              txHash: tx.hash
            };
          case 8:
            _context3.next = 10;
            return _awaitAsyncGenerator(tx.wait());
          case 10:
            _context3.next = 12;
            return {
              key: VoteProposalStep.DONE
            };
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }))();
  }
  /**
   * Executes the given proposal, provided that it has already passed
   *
   * @param {string} proposalId
   * @return {*}  {AsyncGenerator<ExecuteProposalStepValue>}
   * @memberof TokenVotingClient
   */;
  _proto.executeProposal = function executeProposal(proposalId) {
    var _this3 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var signer, _decodeProposalId2, pluginAddress, id, tokenVotingContract, tx;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            signer = _this3.web3.getConnectedSigner();
            _decodeProposalId2 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId2.pluginAddress, id = _decodeProposalId2.id;
            tokenVotingContract = TokenVoting__factory.connect(pluginAddress, signer);
            _context4.next = 5;
            return _awaitAsyncGenerator(tokenVotingContract.execute(id));
          case 5:
            tx = _context4.sent;
            _context4.next = 8;
            return {
              key: ExecuteProposalStep.EXECUTING,
              txHash: tx.hash
            };
          case 8:
            _context4.next = 10;
            return _awaitAsyncGenerator(tx.wait());
          case 10:
            _context4.next = 12;
            return {
              key: ExecuteProposalStep.DONE
            };
          case 12:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }))();
  }
  /**
   * Prepares the installation of a token voting plugin in a given dao
   *
   * @param {TokenVotingPluginPrepareInstallationParams} params
   * @return {*}  {AsyncGenerator<PrepareInstallationStepValue>}
   * @memberof TokenVotingClientMethods
   */;
  _proto.prepareInstallation = function prepareInstallation(params) {
    var _this4 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var signer, networkName, pspContract, tokenVotingRepoContract, versionTag, latestVersion, tokenVotingPluginInstallItem, tx, receipt, pspContractInterface, log, parsedLog, pluginAddress, preparedSetupData;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            signer = _this4.web3.getConnectedSigner();
            networkName = _this4.web3.getNetworkName(); // connect to psp contract
            pspContract = PluginSetupProcessor__factory.connect(LIVE_CONTRACTS[networkName].pluginSetupProcessor, signer); // connect to plugin repo
            tokenVotingRepoContract = PluginRepo__factory.connect(LIVE_CONTRACTS[networkName].tokenVotingRepo, signer); // use specified version or latest
            versionTag = params.versionTag;
            if (params.versionTag) {
              _context5.next = 10;
              break;
            }
            _context5.next = 8;
            return _awaitAsyncGenerator(tokenVotingRepoContract["getLatestVersion(address)"](LIVE_CONTRACTS[networkName].tokenVotingSetup));
          case 8:
            latestVersion = _context5.sent;
            versionTag = {
              build: latestVersion.tag.build,
              release: latestVersion.tag.release
            };
          case 10:
            // get install data
            tokenVotingPluginInstallItem = TokenVotingClientEncoding.getPluginInstallItem(params.settings, networkName); // execute prepareInstallationon
            _context5.next = 13;
            return _awaitAsyncGenerator(pspContract.prepareInstallation(params.daoAddressOrEns, {
              pluginSetupRef: {
                pluginSetupRepo: LIVE_CONTRACTS[networkName].tokenVotingRepo,
                versionTag: versionTag
              },
              data: tokenVotingPluginInstallItem.data
            }));
          case 13:
            tx = _context5.sent;
            _context5.next = 16;
            return {
              key: PrepareInstallationStep.PREPARING,
              txHash: tx.hash
            };
          case 16:
            _context5.next = 18;
            return _awaitAsyncGenerator(tx.wait());
          case 18:
            receipt = _context5.sent;
            pspContractInterface = PluginSetupProcessor__factory.createInterface();
            log = findLog(receipt, pspContractInterface, "InstallationPrepared");
            if (log) {
              _context5.next = 23;
              break;
            }
            throw new PluginInstallationPreparationError();
          case 23:
            parsedLog = pspContractInterface.parseLog(log);
            pluginAddress = parsedLog.args["plugin"];
            preparedSetupData = parsedLog.args["preparedSetupData"];
            if (pluginAddress || preparedSetupData) {
              _context5.next = 28;
              break;
            }
            throw new PluginInstallationPreparationError();
          case 28:
            _context5.next = 30;
            return {
              key: PrepareInstallationStep.DONE,
              pluginAddress: pluginAddress,
              pluginRepo: LIVE_CONTRACTS[networkName].tokenVotingRepo,
              versionTag: versionTag,
              permissions: preparedSetupData.permissions,
              helpers: preparedSetupData.helpers
            };
          case 30:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }))();
  };
  _proto.wrapTokens = function wrapTokens(params) {
    var _this5 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var signer, wrappedErc20Contract, account, tx;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            signer = _this5.web3.getConnectedSigner();
            if (isAddress(params.wrappedTokenAddress)) {
              _context6.next = 3;
              break;
            }
            throw new InvalidAddressError();
          case 3:
            wrappedErc20Contract = GovernanceWrappedERC20__factory.connect(params.wrappedTokenAddress, signer);
            _context6.next = 6;
            return _awaitAsyncGenerator(signer.getAddress());
          case 6:
            account = _context6.sent;
            _context6.next = 9;
            return _awaitAsyncGenerator(wrappedErc20Contract.depositFor(account, params.amount));
          case 9:
            tx = _context6.sent;
            _context6.next = 12;
            return {
              key: WrapTokensStep.WRAPPING,
              txHash: tx.hash
            };
          case 12:
            _context6.next = 14;
            return _awaitAsyncGenerator(tx.wait());
          case 14:
            _context6.next = 16;
            return {
              key: WrapTokensStep.DONE
            };
          case 16:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }))();
  };
  _proto.unwrapTokens = function unwrapTokens(params) {
    var _this6 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      var signer, wrappedErc20Contract, account, tx;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            signer = _this6.web3.getConnectedSigner();
            if (isAddress(params.wrappedTokenAddress)) {
              _context7.next = 3;
              break;
            }
            throw new InvalidAddressError();
          case 3:
            wrappedErc20Contract = GovernanceWrappedERC20__factory.connect(params.wrappedTokenAddress, signer);
            _context7.next = 6;
            return _awaitAsyncGenerator(signer.getAddress());
          case 6:
            account = _context7.sent;
            _context7.next = 9;
            return _awaitAsyncGenerator(wrappedErc20Contract.withdrawTo(account, params.amount));
          case 9:
            tx = _context7.sent;
            _context7.next = 12;
            return {
              key: UnwrapTokensStep.UNWRAPPING,
              txHash: tx.hash
            };
          case 12:
            _context7.next = 14;
            return _awaitAsyncGenerator(tx.wait());
          case 14:
            _context7.next = 16;
            return {
              key: UnwrapTokensStep.DONE
            };
          case 16:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }))();
  }
  /**
   * Delegates all the signer's voting power to a delegatee
   *
   * @param {DelegateTokensParams} params
   * @return {*}  {AsyncGenerator<DelegateTokensStepValue>}
   * @memberof TokenVotingClientMethods
   */;
  _proto.delegateTokens = function delegateTokens(params) {
    var _this7 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      var signer, governanceErc20Contract, tx;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            signer = _this7.web3.getConnectedSigner();
            governanceErc20Contract = GovernanceERC20__factory.connect(params.tokenAddress, signer);
            _context8.next = 4;
            return _awaitAsyncGenerator(governanceErc20Contract.delegate(params.delegatee));
          case 4:
            tx = _context8.sent;
            _context8.next = 7;
            return {
              key: "delegating" /* DELEGATING */,
              txHash: tx.hash
            };
          case 7:
            _context8.next = 9;
            return _awaitAsyncGenerator(tx.wait());
          case 9:
            _context8.next = 11;
            return {
              key: "done" /* DONE */
            };
          case 11:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }))();
  }
  /**
   * Delegates all the signer's tokens back to itself
   *
   * @param {string} tokenAddress
   * @return {*}  {AsyncGenerator<UndelegateTokensStepValue>}
   * @memberof TokenVotingClientMethods
   */;
  _proto.undelegateTokens = function undelegateTokens(tokenAddress) {
    var _this8 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      var signer;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            signer = _this8.web3.getConnectedSigner();
            _context9.t0 = _asyncGeneratorDelegate;
            _context9.t1 = _asyncIterator;
            _context9.t2 = _this8;
            _context9.t3 = tokenAddress;
            _context9.next = 7;
            return _awaitAsyncGenerator(signer.getAddress());
          case 7:
            _context9.t4 = _context9.sent;
            _context9.t5 = {
              tokenAddress: _context9.t3,
              delegatee: _context9.t4
            };
            _context9.t6 = _context9.t2.delegateTokens.call(_context9.t2, _context9.t5);
            _context9.t7 = (0, _context9.t1)(_context9.t6);
            _context9.t8 = _awaitAsyncGenerator;
            return _context9.delegateYield((0, _context9.t0)(_context9.t7, _context9.t8), "t9", 13);
          case 13:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }))();
  }
  /**
   * Retrieves the current signer's delegatee for the given token
   *
   * @param {string} tokenAddress
   * @return {*}  {Promise<string | null>}
   * @memberof TokenVotingClientMethods
   */;
  _proto.getDelegatee =
  /*#__PURE__*/
  function () {
    var _getDelegatee = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(tokenAddress) {
      var signer, governanceErc20Contract, address, delegatee;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            governanceErc20Contract = GovernanceERC20__factory.connect(tokenAddress, signer);
            _context10.next = 4;
            return signer.getAddress();
          case 4:
            address = _context10.sent;
            _context10.next = 7;
            return governanceErc20Contract.delegates(address);
          case 7:
            delegatee = _context10.sent;
            return _context10.abrupt("return", address === delegatee ? null : delegatee);
          case 9:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this);
    }));
    function getDelegatee(_x2) {
      return _getDelegatee.apply(this, arguments);
    }
    return getDelegatee;
  }()
  /**
   * Checks if an user can vote in a proposal
   *
   * @param {CanVoteParams} params
   * @returns {*}  {Promise<boolean>}
   */
  ;
  _proto.canVote =
  /*#__PURE__*/
  function () {
    var _canVote = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(params) {
      var signer, _decodeProposalId3, pluginAddress, id, tokenVotingContract;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            if (isAddress(params.voterAddressOrEns)) {
              _context11.next = 3;
              break;
            }
            throw new InvalidAddressError();
          case 3:
            _decodeProposalId3 = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId3.pluginAddress, id = _decodeProposalId3.id;
            tokenVotingContract = TokenVoting__factory.connect(pluginAddress, signer);
            return _context11.abrupt("return", tokenVotingContract.callStatic.canVote(id, params.voterAddressOrEns, params.vote));
          case 6:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this);
    }));
    function canVote(_x3) {
      return _canVote.apply(this, arguments);
    }
    return canVote;
  }()
  /**
   * Checks whether the current proposal can be executed
   *
   * @param {string} proposalId
   * @return {*}  {Promise<boolean>}
   * @memberof TokenVotingClientMethods
   */
  ;
  _proto.canExecute =
  /*#__PURE__*/
  function () {
    var _canExecute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(proposalId) {
      var signer, _decodeProposalId4, pluginAddress, id, tokenVotingContract;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _decodeProposalId4 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId4.pluginAddress, id = _decodeProposalId4.id;
            tokenVotingContract = TokenVoting__factory.connect(pluginAddress, signer);
            return _context12.abrupt("return", tokenVotingContract.canExecute(id));
          case 4:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this);
    }));
    function canExecute(_x4) {
      return _canExecute.apply(this, arguments);
    }
    return canExecute;
  }()
  /**
   * Returns the list of wallet addresses holding tokens from the underlying Token contract used by the plugin
   *
   * @async
   * @param {string} pluginAddress
   * @return {*}  {Promise<string[]>}
   * @memberof TokenVotingClient
   */
  ;
  _proto.getMembers =
  /*#__PURE__*/
  function () {
    var _getMembers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(pluginAddress) {
      var query, params, name, _yield$this$graphql$r, tokenVotingPlugin;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            if (isAddress(pluginAddress)) {
              _context13.next = 2;
              break;
            }
            throw new InvalidAddressError();
          case 2:
            query = QueryTokenVotingMembers;
            params = {
              address: pluginAddress.toLowerCase()
            };
            name = "TokenVoting members";
            _context13.next = 7;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 7:
            _yield$this$graphql$r = _context13.sent;
            tokenVotingPlugin = _yield$this$graphql$r.tokenVotingPlugin;
            return _context13.abrupt("return", tokenVotingPlugin.members.map(function (member) {
              return toTokenVotingMember(member);
            }));
          case 10:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this);
    }));
    function getMembers(_x5) {
      return _getMembers.apply(this, arguments);
    }
    return getMembers;
  }()
  /**
   * Returns the details of the given proposal
   *
   * @param {string} proposalId
   * @return {*}  {Promise<TokenVotingProposal>}
   * @memberof TokenVotingClient
   */
  ;
  _proto.getProposal =
  /*#__PURE__*/
  function () {
    var _getProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(proposalId) {
      var extendedProposalId, query, params, name, _yield$this$graphql$r2, tokenVotingProposal, metadataCid, metadataString, metadata;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            if (isProposalId(proposalId)) {
              _context14.next = 2;
              break;
            }
            throw new InvalidProposalIdError();
          case 2:
            extendedProposalId = getExtendedProposalId(proposalId);
            query = QueryTokenVotingProposal;
            params = {
              proposalId: extendedProposalId
            };
            name = "TokenVoting proposal";
            _context14.next = 8;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 8:
            _yield$this$graphql$r2 = _context14.sent;
            tokenVotingProposal = _yield$this$graphql$r2.tokenVotingProposal;
            if (tokenVotingProposal) {
              _context14.next = 14;
              break;
            }
            return _context14.abrupt("return", null);
          case 14:
            if (tokenVotingProposal.metadata) {
              _context14.next = 16;
              break;
            }
            return _context14.abrupt("return", toTokenVotingProposal(tokenVotingProposal, EMPTY_PROPOSAL_METADATA_LINK));
          case 16:
            _context14.prev = 16;
            metadataCid = resolveIpfsCid(tokenVotingProposal.metadata);
            _context14.next = 20;
            return this.ipfs.fetchString(metadataCid);
          case 20:
            metadataString = _context14.sent;
            metadata = JSON.parse(metadataString);
            return _context14.abrupt("return", toTokenVotingProposal(tokenVotingProposal, metadata));
          case 25:
            _context14.prev = 25;
            _context14.t0 = _context14["catch"](16);
            if (!(_context14.t0 instanceof InvalidCidError)) {
              _context14.next = 29;
              break;
            }
            return _context14.abrupt("return", toTokenVotingProposal(tokenVotingProposal, UNSUPPORTED_PROPOSAL_METADATA_LINK));
          case 29:
            return _context14.abrupt("return", toTokenVotingProposal(tokenVotingProposal, UNAVAILABLE_PROPOSAL_METADATA));
          case 30:
          case "end":
            return _context14.stop();
        }
      }, _callee14, this, [[16, 25]]);
    }));
    function getProposal(_x6) {
      return _getProposal.apply(this, arguments);
    }
    return getProposal;
  }()
  /**
   * Returns a list of proposals on the Plugin, filtered by the given criteria
   *
   * @param {ProposalQueryParams} params
   * @return {*}  {Promise<TokenVotingProposalListItem[]>}
   * @memberof TokenVotingClient
   */
  ;
  _proto.getProposals =
  /*#__PURE__*/
  function () {
    var _getProposals = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(_ref) {
      var _this9 = this;
      var daoAddressOrEns, _ref$limit, limit, status, _ref$skip, skip, _ref$direction, direction, _ref$sortBy, sortBy, where, address, provider, resolvedAddress, query, params, name, _yield$this$graphql$r3, tokenVotingProposals;
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            daoAddressOrEns = _ref.daoAddressOrEns, _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? 10 : _ref$limit, status = _ref.status, _ref$skip = _ref.skip, skip = _ref$skip === void 0 ? 0 : _ref$skip, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? SortDirection.ASC : _ref$direction, _ref$sortBy = _ref.sortBy, sortBy = _ref$sortBy === void 0 ? ProposalSortBy.CREATED_AT : _ref$sortBy;
            where = {};
            address = daoAddressOrEns;
            if (!address) {
              _context16.next = 23;
              break;
            }
            if (isAddress(address)) {
              _context16.next = 22;
              break;
            }
            _context16.next = 7;
            return this.web3.ensureOnline();
          case 7:
            provider = this.web3.getProvider();
            if (provider) {
              _context16.next = 10;
              break;
            }
            throw new NoProviderError();
          case 10:
            _context16.prev = 10;
            _context16.next = 13;
            return provider.resolveName(address);
          case 13:
            resolvedAddress = _context16.sent;
            if (resolvedAddress) {
              _context16.next = 16;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 16:
            address = resolvedAddress;
            _context16.next = 22;
            break;
          case 19:
            _context16.prev = 19;
            _context16.t0 = _context16["catch"](10);
            throw new InvalidAddressOrEnsError(_context16.t0);
          case 22:
            where = {
              dao: address.toLowerCase()
            };
          case 23:
            if (status) {
              where = _extends({}, where, computeProposalStatusFilter(status));
            }
            query = QueryTokenVotingProposals;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "TokenVoting proposals";
            _context16.next = 29;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 29:
            _yield$this$graphql$r3 = _context16.sent;
            tokenVotingProposals = _yield$this$graphql$r3.tokenVotingProposals;
            return _context16.abrupt("return", Promise.all(tokenVotingProposals.map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(proposal) {
                var metadataCid, stringMetadata, metadata;
                return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      if (proposal.metadata) {
                        _context15.next = 2;
                        break;
                      }
                      return _context15.abrupt("return", toTokenVotingProposalListItem(proposal, EMPTY_PROPOSAL_METADATA_LINK));
                    case 2:
                      _context15.prev = 2;
                      metadataCid = resolveIpfsCid(proposal.metadata);
                      _context15.next = 6;
                      return _this9.ipfs.fetchString(metadataCid);
                    case 6:
                      stringMetadata = _context15.sent;
                      metadata = JSON.parse(stringMetadata);
                      return _context15.abrupt("return", toTokenVotingProposalListItem(proposal, metadata));
                    case 11:
                      _context15.prev = 11;
                      _context15.t0 = _context15["catch"](2);
                      if (!(_context15.t0 instanceof InvalidCidError)) {
                        _context15.next = 15;
                        break;
                      }
                      return _context15.abrupt("return", toTokenVotingProposalListItem(proposal, UNSUPPORTED_PROPOSAL_METADATA_LINK));
                    case 15:
                      return _context15.abrupt("return", toTokenVotingProposalListItem(proposal, UNAVAILABLE_PROPOSAL_METADATA));
                    case 16:
                    case "end":
                      return _context15.stop();
                  }
                }, _callee15, null, [[2, 11]]);
              }));
              return function (_x8) {
                return _ref2.apply(this, arguments);
              };
            }())));
          case 32:
          case "end":
            return _context16.stop();
        }
      }, _callee16, this, [[10, 19]]);
    }));
    function getProposals(_x7) {
      return _getProposals.apply(this, arguments);
    }
    return getProposals;
  }()
  /**
   * Returns the settings of a plugin given the address of the plugin instance
   *
   * @param {string} pluginAddress
   * @return {*}  {Promise<VotingSettings>}
   * @memberof TokenVotingClient
   */
  ;
  _proto.getVotingSettings =
  /*#__PURE__*/
  function () {
    var _getVotingSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(pluginAddress) {
      var query, params, name, _yield$this$graphql$r4, tokenVotingPlugin;
      return _regeneratorRuntime().wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            if (isAddress(pluginAddress)) {
              _context17.next = 2;
              break;
            }
            throw new InvalidAddressError();
          case 2:
            query = QueryTokenVotingSettings;
            params = {
              address: pluginAddress.toLowerCase()
            };
            name = "TokenVoting settings";
            _context17.next = 7;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 7:
            _yield$this$graphql$r4 = _context17.sent;
            tokenVotingPlugin = _yield$this$graphql$r4.tokenVotingPlugin;
            if (tokenVotingPlugin) {
              _context17.next = 11;
              break;
            }
            return _context17.abrupt("return", null);
          case 11:
            return _context17.abrupt("return", {
              minDuration: parseInt(tokenVotingPlugin.minDuration),
              supportThreshold: decodeRatio(BigInt(tokenVotingPlugin.supportThreshold), 6),
              minParticipation: decodeRatio(BigInt(tokenVotingPlugin.minParticipation), 6),
              minProposerVotingPower: BigInt(tokenVotingPlugin.minProposerVotingPower),
              votingMode: tokenVotingPlugin.votingMode
            });
          case 12:
          case "end":
            return _context17.stop();
        }
      }, _callee17, this);
    }));
    function getVotingSettings(_x9) {
      return _getVotingSettings.apply(this, arguments);
    }
    return getVotingSettings;
  }()
  /**
   * Returns the details of the token used in a specific plugin instance
   *
   * @param {string} pluginAddress
   * @return {*}  {Promise<Erc20TokenDetails | null>}
   * @memberof TokenVotingClient
   */
  ;
  _proto.getToken =
  /*#__PURE__*/
  function () {
    var _getToken = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(pluginAddress) {
      var query, params, name, _yield$this$graphql$r5, tokenVotingPlugin, token;
      return _regeneratorRuntime().wrap(function _callee18$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            if (isAddress(pluginAddress)) {
              _context18.next = 2;
              break;
            }
            throw new InvalidAddressError();
          case 2:
            query = QueryTokenVotingPlugin;
            params = {
              address: pluginAddress.toLowerCase()
            };
            name = "TokenVoting token";
            _context18.next = 7;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 7:
            _yield$this$graphql$r5 = _context18.sent;
            tokenVotingPlugin = _yield$this$graphql$r5.tokenVotingPlugin;
            if (tokenVotingPlugin) {
              _context18.next = 11;
              break;
            }
            return _context18.abrupt("return", null);
          case 11:
            token = tokenVotingPlugin.token; // type erc20
            if (!(token.__typename === SubgraphContractType.ERC20)) {
              _context18.next = 16;
              break;
            }
            return _context18.abrupt("return", {
              address: token.id,
              name: token.name,
              symbol: token.symbol,
              decimals: token.decimals,
              type: TokenType.ERC20
            });
          case 16:
            if (!(token.__typename === SubgraphContractType.ERC721)) {
              _context18.next = 18;
              break;
            }
            return _context18.abrupt("return", {
              address: token.id,
              name: token.name,
              symbol: token.symbol,
              type: TokenType.ERC721
            });
          case 18:
            return _context18.abrupt("return", null);
          case 19:
          case "end":
            return _context18.stop();
        }
      }, _callee18, this);
    }));
    function getToken(_x10) {
      return _getToken.apply(this, arguments);
    }
    return getToken;
  }();
  return TokenVotingClientMethods;
}(ClientCore);

var AVAILABLE_FUNCTION_SIGNATURES$2 = [/*#__PURE__*/MajorityVotingBase__factory.createInterface().getFunction("updateVotingSettings").format("minimal"), /*#__PURE__*/IERC20MintableUpgradeable__factory.createInterface().getFunction("mint").format("minimal")];

/**
 * Decoding module the SDK TokenVoting Client
 */
var TokenVotingClientDecoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(TokenVotingClientDecoding, _ClientCore);
  function TokenVotingClientDecoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = TokenVotingClientDecoding.prototype;
  /**
   * Decodes a dao metadata from an encoded update metadata action
   *
   * @param {Uint8Array} data
   * @return {*}  {VotingSettings}
   * @memberof TokenVotingClientDecoding
   */
  _proto.updatePluginSettingsAction = function updatePluginSettingsAction(data) {
    return decodeUpdatePluginSettingsAction(data);
  }
  /**
   * Decodes the mint token params from an encoded mint token action
   *
   * @param {Uint8Array} data
   * @return {*}  {MintTokenParams}
   * @memberof TokenVotingClientDecoding
   */;
  _proto.mintTokenAction = function mintTokenAction(data) {
    var votingInterface = IERC20MintableUpgradeable__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedfunction = votingInterface.getFunction("mint");
    var result = votingInterface.decodeFunctionData(expectedfunction, hexBytes);
    return mintTokenParamsFromContract(result);
  }
  /**
   * Returns the decoded function info given the encoded data of an action
   *
   * @param {Uint8Array} data
   * @return {*}  {(InterfaceParams | null)}
   * @memberof TokenVotingClientDecoding
   */;
  _proto.findInterface = function findInterface(data) {
    try {
      var func = getFunctionFragment(data, AVAILABLE_FUNCTION_SIGNATURES$2);
      return {
        id: func.format("minimal"),
        functionName: func.name,
        hash: bytesToHex(data).substring(0, 10)
      };
    } catch (_unused) {
      return null;
    }
  };
  return TokenVotingClientDecoding;
}(ClientCore);

/**
 * Estimation module the SDK TokenVoting Client
 */
var TokenVotingClientEstimation = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(TokenVotingClientEstimation, _ClientCore);
  function TokenVotingClientEstimation() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = TokenVotingClientEstimation.prototype;
  /**
   * Estimates the gas fee of creating a proposal on the plugin
   *
   * @param {CreateMajorityVotingProposalParams} params
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof TokenVotingClientEstimation
   */
  _proto.createProposal =
  /*#__PURE__*/
  function () {
    var _createProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var _params$failSafeActio, _params$actions, _params$startDate, _params$endDate;
      var signer, tokenVotingContract, allowFailureMap, startTimestamp, endTimestamp, estimatedGasFee;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            tokenVotingContract = TokenVoting__factory.connect(params.pluginAddress, signer);
            if (!((_params$failSafeActio = params.failSafeActions) != null && _params$failSafeActio.length && params.failSafeActions.length !== ((_params$actions = params.actions) == null ? void 0 : _params$actions.length))) {
              _context.next = 4;
              break;
            }
            throw new Error("Size mismatch: actions and failSafeActions should match");
          case 4:
            allowFailureMap = boolArrayToBitmap(params.failSafeActions);
            startTimestamp = ((_params$startDate = params.startDate) == null ? void 0 : _params$startDate.getTime()) || 0;
            endTimestamp = ((_params$endDate = params.endDate) == null ? void 0 : _params$endDate.getTime()) || 0;
            _context.next = 9;
            return tokenVotingContract.estimateGas.createProposal(toUtf8Bytes(params.metadataUri), params.actions || [], allowFailureMap, Math.round(startTimestamp / 1000), Math.round(endTimestamp / 1000), params.creatorVote || 0, params.executeOnPass || false);
          case 9:
            estimatedGasFee = _context.sent;
            return _context.abrupt("return", this.web3.getApproximateGasFee(estimatedGasFee.toBigInt()));
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function createProposal(_x) {
      return _createProposal.apply(this, arguments);
    }
    return createProposal;
  }()
  /**
   * Estimates the gas fee of casting a vote on a proposal
   *
   * @param {VoteProposalParams} params
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof TokenVotingClientEstimation
   */
  ;
  _proto.voteProposal =
  /*#__PURE__*/
  function () {
    var _voteProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var signer, _decodeProposalId, pluginAddress, id, tokenVotingContract, estimation;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _decodeProposalId = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId.pluginAddress, id = _decodeProposalId.id;
            tokenVotingContract = TokenVoting__factory.connect(pluginAddress, signer);
            _context2.next = 5;
            return tokenVotingContract.estimateGas.vote(id, params.vote, false);
          case 5:
            estimation = _context2.sent;
            return _context2.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function voteProposal(_x2) {
      return _voteProposal.apply(this, arguments);
    }
    return voteProposal;
  }()
  /**
   * Estimates the gas fee of executing a TokenVoting proposal
   *
   * @param {string} proposalId
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof TokenVotingClientEstimation
   */
  ;
  _proto.executeProposal =
  /*#__PURE__*/
  function () {
    var _executeProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(proposalId) {
      var signer, _decodeProposalId2, pluginAddress, id, tokenVotingContract, estimation;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _decodeProposalId2 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId2.pluginAddress, id = _decodeProposalId2.id;
            tokenVotingContract = TokenVoting__factory.connect(pluginAddress, signer);
            _context3.next = 5;
            return tokenVotingContract.estimateGas.execute(id);
          case 5:
            estimation = _context3.sent;
            return _context3.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 7:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function executeProposal(_x3) {
      return _executeProposal.apply(this, arguments);
    }
    return executeProposal;
  }()
  /**
   * Estimates the gas fee of delegating voting power to a delegatee
   *
   * @param {DelegateTokensParams} params
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof TokenVotingClientEstimation
   */
  ;
  _proto.delegateTokens =
  /*#__PURE__*/
  function () {
    var _delegateTokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(params) {
      var signer, governanceErc20Contract, estimation;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            governanceErc20Contract = GovernanceERC20__factory.connect(params.tokenAddress, signer);
            _context4.next = 4;
            return governanceErc20Contract.estimateGas.delegate(params.delegatee);
          case 4:
            estimation = _context4.sent;
            return _context4.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 6:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function delegateTokens(_x4) {
      return _delegateTokens.apply(this, arguments);
    }
    return delegateTokens;
  }()
  /**
   * Estimates the gas fee of undelegating voting power
   *
   * @param {string} tokenAddress
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof TokenVotingClientEstimation
   */
  ;
  _proto.undelegateTokens =
  /*#__PURE__*/
  function () {
    var _undelegateTokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(tokenAddress) {
      var signer;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _context5.t0 = this;
            _context5.t1 = tokenAddress;
            _context5.next = 5;
            return signer.getAddress();
          case 5:
            _context5.t2 = _context5.sent;
            _context5.t3 = {
              tokenAddress: _context5.t1,
              delegatee: _context5.t2
            };
            return _context5.abrupt("return", _context5.t0.delegateTokens.call(_context5.t0, _context5.t3));
          case 8:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function undelegateTokens(_x5) {
      return _undelegateTokens.apply(this, arguments);
    }
    return undelegateTokens;
  }();
  return TokenVotingClientEstimation;
}(ClientCore);

/**
 * Provider a generic client with high level methods to manage and interact a Token Voting plugin installed in a DAO
 */
var TokenVotingClient = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(TokenVotingClient, _ClientCore);
  function TokenVotingClient(context) {
    var _this;
    _this = _ClientCore.call(this, context) || this;
    _this.methods = new TokenVotingClientMethods(context);
    _this.encoding = new TokenVotingClientEncoding(context);
    _this.decoding = new TokenVotingClientDecoding(context);
    _this.estimation = new TokenVotingClientEstimation(context);
    return _this;
  }
  return TokenVotingClient;
}(ClientCore);
TokenVotingClient.encoding = {
  /**
   * Computes the parameters to be given when creating the DAO,
   * so that the plugin is configured
   *
   * @param {TokenVotingPluginInstall} params
   * @param {Networkish} [network="mainnet"]
   * @return {*}  {PluginInstallItem}
   * @memberof TokenVotingClient
   */
  getPluginInstallItem: function getPluginInstallItem(params, network) {
    if (network === void 0) {
      network = "mainnet";
    }
    return TokenVotingClientEncoding.getPluginInstallItem(params, network);
  }
};

var ApproveProposalStep;
(function (ApproveProposalStep) {
  ApproveProposalStep["APPROVING"] = "approving";
  ApproveProposalStep["DONE"] = "done";
})(ApproveProposalStep || (ApproveProposalStep = {}));

var _templateObject$c, _templateObject2$4;
var QueryMultisigProposal = /*#__PURE__*/gql(_templateObject$c || (_templateObject$c = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery MultisigProposal($proposalId: ID!) {\n  multisigProposal(id: $proposalId){\n    id\n    dao {\n      id\n      subdomain\n    }\n    creator\n    metadata\n    createdAt\n    startDate\n    endDate\n    actions {\n      to\n      value\n      data\n    }\n    executionDate\n    executionBlockNumber\n    creationBlockNumber\n    plugin {\n      onlyListed\n    }\n    minApprovals\n    executionTxHash\n    executed\n    potentiallyExecutable\n    approvers{\n      id\n    }\n  }\n}\n"])));
var QueryMultisigProposals = /*#__PURE__*/gql(_templateObject2$4 || (_templateObject2$4 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery MultisigProposals($where: MultisigProposal_filter!, $limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: MultisigProposal_orderBy!) {\n  multisigProposals(where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy){\n    id\n    dao {\n      id\n      subdomain\n    }\n    creator\n    metadata\n    executed\n    potentiallyExecutable\n    approvals\n    startDate\n    endDate\n    executionDate\n    executionBlockNumber\n    creationBlockNumber\n    approvers {\n      id\n    }\n    minApprovals\n    plugin{\n      onlyListed\n    }\n  }\n}\n"])));

var _templateObject$d;
var QueryMultisigVotingSettings = /*#__PURE__*/gql(_templateObject$d || (_templateObject$d = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery MultisigVotingSettings($address: ID!) {\n    multisigPlugin(id: $address){\n        minApprovals\n        onlyListed\n    }\n}\n"])));

var _templateObject$e;
var QueryMultisigMembers = /*#__PURE__*/gql(_templateObject$e || (_templateObject$e = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery MultisigMembers($address: ID!) {\n    multisigPlugin(id: $address){\n        members {\n            address\n        }\n    }\n}\n"])));

function toMultisigProposal(proposal, metadata) {
  var creationDate = new Date(parseInt(proposal.createdAt) * 1000);
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  var executionDate = proposal.executionDate ? new Date(parseInt(proposal.executionDate) * 1000) : null;
  return {
    id: getCompactProposalId(proposal.id),
    dao: {
      address: proposal.dao.id,
      name: proposal.dao.subdomain
    },
    creatorAddress: proposal.creator,
    metadata: {
      title: metadata.title,
      summary: metadata.summary,
      description: metadata.description,
      resources: metadata.resources,
      media: metadata.media
    },
    settings: {
      onlyListed: proposal.plugin.onlyListed,
      minApprovals: proposal.minApprovals
    },
    creationBlockNumber: parseInt(proposal.creationBlockNumber) || 0,
    creationDate: creationDate,
    startDate: startDate,
    endDate: endDate,
    executionDate: executionDate,
    executionBlockNumber: parseInt(proposal.executionBlockNumber) || null,
    executionTxHash: proposal.executionTxHash || null,
    actions: proposal.actions.map(function (action) {
      return {
        data: hexToBytes(action.data),
        to: action.to,
        value: BigInt(action.value)
      };
    }),
    status: computeProposalStatus(proposal),
    approvals: proposal.approvers.map(function (approver) {
      return approver.id.slice(0, 42);
    })
  };
}
function toMultisigProposalListItem(proposal, metadata) {
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  return {
    id: getCompactProposalId(proposal.id),
    dao: {
      address: proposal.dao.id,
      name: proposal.dao.subdomain
    },
    creatorAddress: proposal.creator,
    metadata: {
      title: metadata.title,
      summary: metadata.summary
    },
    approvals: proposal.approvers.map(function (approver) {
      return approver.id.slice(0, 42);
    }),
    settings: {
      onlyListed: proposal.plugin.onlyListed,
      minApprovals: proposal.minApprovals
    },
    startDate: startDate,
    endDate: endDate,
    status: computeProposalStatus(proposal)
  };
}

/**
 * Encoding module for the SDK Multisig Client
 */
var MultisigClientEncoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(MultisigClientEncoding, _ClientCore);
  function MultisigClientEncoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  /**
   * Computes the parameters to be given when creating the DAO,
   * so that the plugin is configured
   *
   * @param {MultisigPluginInstallParams} params
   * @param {Networkish} network
   *
   * @return {*}  {PluginInstallItem}
   * @memberof MultisigClientEncoding
   */
  MultisigClientEncoding.getPluginInstallItem = function getPluginInstallItem(params, network) {
    var networkName = getNetwork(network).name;
    if (!SupportedNetworksArray.includes(networkName)) {
      throw new UnsupportedNetworkError(networkName);
    }
    var hexBytes = defaultAbiCoder.encode(
    // members, [onlyListed, minApprovals]
    ["address[]", "tuple(bool, uint16)"], [params.members, [params.votingSettings.onlyListed, params.votingSettings.minApprovals]]);
    return {
      id: LIVE_CONTRACTS[networkName].multisigRepo,
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that updates the governance configuration
   *
   * @param {AddAddressesParams} params
   * @return {*}  {DaoAction[]}
   * @memberof MultisigClientEncoding
   */;
  var _proto = MultisigClientEncoding.prototype;
  _proto.addAddressesAction = function addAddressesAction(params) {
    if (!isAddress(params.pluginAddress)) {
      throw new InvalidAddressError();
    }
    // TODO yup validation
    for (var _iterator = _createForOfIteratorHelperLoose(params.members), _step; !(_step = _iterator()).done;) {
      var member = _step.value;
      if (!isAddress(member)) {
        throw new InvalidAddressError();
      }
    }
    var multisigInterface = Multisig__factory.createInterface();
    // get hex bytes
    var hexBytes = multisigInterface.encodeFunctionData("addAddresses", [params.members]);
    return {
      to: params.pluginAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that adds addresses to address list
   *
   * @param {RemoveAddressesParams} params
   * @return {*}  {DaoAction[]}
   * @memberof MultisigClientEncoding
   */;
  _proto.removeAddressesAction = function removeAddressesAction(params) {
    if (!isAddress(params.pluginAddress)) {
      throw new InvalidAddressError();
    }
    // TODO yup validation
    for (var _iterator2 = _createForOfIteratorHelperLoose(params.members), _step2; !(_step2 = _iterator2()).done;) {
      var member = _step2.value;
      if (!isAddress(member)) {
        throw new InvalidAddressError();
      }
    }
    var multisigInterface = Multisig__factory.createInterface();
    // get hex bytes
    var hexBytes = multisigInterface.encodeFunctionData("removeAddresses", [params.members]);
    return {
      to: params.pluginAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal updates multisig settings
   *
   * @param {UpdateMultisigVotingSettingsParams} params
   * @return {*}  {DaoAction}
   * @memberof MultisigClientEncoding
   */;
  _proto.updateMultisigVotingSettings = function updateMultisigVotingSettings(params) {
    if (!isAddress(params.pluginAddress)) {
      throw new InvalidAddressError();
    }
    var multisigInterface = Multisig__factory.createInterface();
    // get hex bytes
    var hexBytes = multisigInterface.encodeFunctionData("updateMultisigSettings", [params.votingSettings]);
    return {
      to: params.pluginAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  };
  return MultisigClientEncoding;
}(ClientCore);

/**
 * Methods module the SDK Address List Client
 */
var MultisigClientMethods = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(MultisigClientMethods, _ClientCore);
  function MultisigClientMethods() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = MultisigClientMethods.prototype;
  /**
   * Creates a new proposal on the given multisig plugin contract
   *
   * @param {CreateMultisigProposalParams} params
   * @return {*}  {AsyncGenerator<ProposalCreationStepValue>}
   * @memberof MultisigClientMethods
   */
  _proto.createProposal = function createProposal(params) {
    var _this = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _params$failSafeActio, _params$actions, _params$startDate, _params$endDate;
      var signer, multisigContract, allowFailureMap, startTimestamp, endTimestamp, tx, receipt, multisigContractInterface, log, parsedLog, proposalId;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            signer = _this.web3.getConnectedSigner();
            multisigContract = Multisig__factory.connect(params.pluginAddress, signer);
            if (!((_params$failSafeActio = params.failSafeActions) != null && _params$failSafeActio.length && params.failSafeActions.length !== ((_params$actions = params.actions) == null ? void 0 : _params$actions.length))) {
              _context.next = 4;
              break;
            }
            throw new Error("Size mismatch: actions and failSafeActions should match");
          case 4:
            allowFailureMap = boolArrayToBitmap(params.failSafeActions);
            startTimestamp = ((_params$startDate = params.startDate) == null ? void 0 : _params$startDate.getTime()) || 0;
            endTimestamp = ((_params$endDate = params.endDate) == null ? void 0 : _params$endDate.getTime()) || 0;
            _context.next = 9;
            return _awaitAsyncGenerator(multisigContract.createProposal(toUtf8Bytes(params.metadataUri), params.actions || [], allowFailureMap, params.approve || false, params.tryExecution || false, Math.round(startTimestamp / 1000), Math.round(endTimestamp / 1000)));
          case 9:
            tx = _context.sent;
            _context.next = 12;
            return {
              key: ProposalCreationSteps.CREATING,
              txHash: tx.hash
            };
          case 12:
            _context.next = 14;
            return _awaitAsyncGenerator(tx.wait());
          case 14:
            receipt = _context.sent;
            multisigContractInterface = Multisig__factory.createInterface();
            log = findLog(receipt, multisigContractInterface, "ProposalCreated");
            if (log) {
              _context.next = 19;
              break;
            }
            throw new ProposalCreationError();
          case 19:
            parsedLog = multisigContractInterface.parseLog(log);
            proposalId = parsedLog.args["proposalId"];
            if (proposalId) {
              _context.next = 23;
              break;
            }
            throw new ProposalCreationError();
          case 23:
            _context.next = 25;
            return {
              key: ProposalCreationSteps.DONE,
              proposalId: encodeProposalId(params.pluginAddress, Number(proposalId))
            };
          case 25:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  }
  /**
   * Pins a metadata object into IPFS and retruns the generated hash
   *
   * @param {ProposalMetadata} params
   * @return {*}  {Promise<string>}
   * @memberof MultisigClientMethods
   */;
  _proto.pinMetadata =
  /*#__PURE__*/
  function () {
    var _pinMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var cid;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.ipfs.add(JSON.stringify(params));
          case 3:
            cid = _context2.sent;
            _context2.next = 6;
            return this.ipfs.pin(cid);
          case 6:
            return _context2.abrupt("return", "ipfs://" + cid);
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](0);
            throw new IpfsPinError(_context2.t0);
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[0, 9]]);
    }));
    function pinMetadata(_x) {
      return _pinMetadata.apply(this, arguments);
    }
    return pinMetadata;
  }()
  /**
   * Allow a wallet in the multisig give approval to a proposal
   *
   * @param {ApproveMultisigProposalParams} params
   * @return {*}  {AsyncGenerator<ApproveProposalStepValue>}
   * @memberof MultisigClientMethods
   */
  ;
  _proto.approveProposal = function approveProposal(params) {
    var _this2 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var signer, _decodeProposalId, pluginAddress, id, multisigContract, tx;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            signer = _this2.web3.getConnectedSigner();
            _decodeProposalId = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId.pluginAddress, id = _decodeProposalId.id;
            multisigContract = Multisig__factory.connect(pluginAddress, signer);
            _context3.next = 5;
            return _awaitAsyncGenerator(multisigContract.approve(id, params.tryExecution));
          case 5:
            tx = _context3.sent;
            _context3.next = 8;
            return {
              key: ApproveProposalStep.APPROVING,
              txHash: tx.hash
            };
          case 8:
            _context3.next = 10;
            return _awaitAsyncGenerator(tx.wait());
          case 10:
            _context3.next = 12;
            return {
              key: ApproveProposalStep.DONE
            };
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }))();
  }
  /**
   * Allow a wallet in the multisig give approval to a proposal
   *
   * @param {string} proposalId
   * @return {*}  {AsyncGenerator<ExecuteMultisigProposalStepValue>}
   * @memberof MultisigClientMethods
   */;
  _proto.executeProposal = function executeProposal(proposalId) {
    var _this3 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var signer, _decodeProposalId2, pluginAddress, id, multisigContract, tx;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            signer = _this3.web3.getConnectedSigner();
            _decodeProposalId2 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId2.pluginAddress, id = _decodeProposalId2.id;
            multisigContract = Multisig__factory.connect(pluginAddress, signer);
            _context4.next = 5;
            return _awaitAsyncGenerator(multisigContract.execute(id));
          case 5:
            tx = _context4.sent;
            _context4.next = 8;
            return {
              key: ExecuteProposalStep.EXECUTING,
              txHash: tx.hash
            };
          case 8:
            _context4.next = 10;
            return _awaitAsyncGenerator(tx.wait());
          case 10:
            _context4.next = 12;
            return {
              key: ExecuteProposalStep.DONE
            };
          case 12:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }))();
  }
  /**
   * Prepares the installation of a multisig plugin in a given dao
   *
   * @param {MultisigPluginPrepareInstallationParams} params
   * @return {*}  {AsyncGenerator<PrepareInstallationStepValue>}
   * @memberof MultisigClientMethods
   */;
  _proto.prepareInstallation = function prepareInstallation(params) {
    var _this4 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var signer, networkName, pspContract, multisigRepoContract, versionTag, latestVersion, multisigPluginInstallItem, tx, receipt, pspContractInterface, log, parsedLog, pluginAddress, preparedSetupData;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            signer = _this4.web3.getConnectedSigner();
            networkName = _this4.web3.getNetworkName(); // connect to psp contract
            pspContract = PluginSetupProcessor__factory.connect(LIVE_CONTRACTS[networkName].pluginSetupProcessor, signer); // connect to plugin repo
            multisigRepoContract = PluginRepo__factory.connect(LIVE_CONTRACTS[networkName].multisigRepo, signer); // use specified version or latest
            versionTag = params.versionTag;
            if (params.versionTag) {
              _context5.next = 10;
              break;
            }
            _context5.next = 8;
            return _awaitAsyncGenerator(multisigRepoContract["getLatestVersion(address)"](LIVE_CONTRACTS[networkName].multisigSetup));
          case 8:
            latestVersion = _context5.sent;
            versionTag = {
              build: latestVersion.tag.build,
              release: latestVersion.tag.release
            };
          case 10:
            // get install data
            multisigPluginInstallItem = MultisigClientEncoding.getPluginInstallItem(params.settings, networkName); // execute prepareInstallation
            _context5.next = 13;
            return _awaitAsyncGenerator(pspContract.prepareInstallation(params.daoAddressOrEns, {
              pluginSetupRef: {
                pluginSetupRepo: LIVE_CONTRACTS[networkName].multisigRepo,
                versionTag: versionTag
              },
              data: multisigPluginInstallItem.data
            }));
          case 13:
            tx = _context5.sent;
            _context5.next = 16;
            return {
              key: PrepareInstallationStep.PREPARING,
              txHash: tx.hash
            };
          case 16:
            _context5.next = 18;
            return _awaitAsyncGenerator(tx.wait());
          case 18:
            receipt = _context5.sent;
            pspContractInterface = PluginSetupProcessor__factory.createInterface();
            log = findLog(receipt, pspContractInterface, "InstallationPrepared");
            if (log) {
              _context5.next = 23;
              break;
            }
            throw new ProposalCreationError();
          case 23:
            parsedLog = pspContractInterface.parseLog(log);
            pluginAddress = parsedLog.args["plugin"];
            preparedSetupData = parsedLog.args["preparedSetupData"];
            if (pluginAddress || preparedSetupData) {
              _context5.next = 28;
              break;
            }
            throw new PluginInstallationPreparationError();
          case 28:
            _context5.next = 30;
            return {
              key: PrepareInstallationStep.DONE,
              pluginAddress: pluginAddress,
              pluginRepo: LIVE_CONTRACTS[networkName].multisigRepo,
              versionTag: versionTag,
              permissions: preparedSetupData.permissions,
              helpers: preparedSetupData.helpers
            };
          case 30:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }))();
  }
  /**
   * Checks whether the current proposal can be approved by the given address
   *
   * @param {string} addressOrEns
   * @return {*}  {Promise<boolean>}
   * @memberof MultisigClientMethods
   */;
  _proto.canApprove =
  /*#__PURE__*/
  function () {
    var _canApprove = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(params) {
      var signer, _decodeProposalId3, pluginAddress, id, multisigContract;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            if (isAddress(params.approverAddressOrEns)) {
              _context6.next = 3;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 3:
            _decodeProposalId3 = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId3.pluginAddress, id = _decodeProposalId3.id;
            multisigContract = Multisig__factory.connect(pluginAddress, signer);
            return _context6.abrupt("return", multisigContract.canApprove(id, params.approverAddressOrEns));
          case 6:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function canApprove(_x2) {
      return _canApprove.apply(this, arguments);
    }
    return canApprove;
  }()
  /**
   * Checks whether the current proposal can be executed
   *
   * @param {string} proposalId
   * @return {*}  {Promise<boolean>}
   * @memberof MultisigClientMethods
   */
  ;
  _proto.canExecute =
  /*#__PURE__*/
  function () {
    var _canExecute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(proposalId) {
      var signer, _decodeProposalId4, pluginAddress, id, multisigContract;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _decodeProposalId4 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId4.pluginAddress, id = _decodeProposalId4.id;
            multisigContract = Multisig__factory.connect(pluginAddress, signer);
            return _context7.abrupt("return", multisigContract.canExecute(id));
          case 4:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
    function canExecute(_x3) {
      return _canExecute.apply(this, arguments);
    }
    return canExecute;
  }()
  /**
   * Returns the voting settings
   *
   * @param {string} addressOrEns
   * @return {*}  {Promise<MultisigVotingSettings>}
   * @memberof MultisigClientMethods
   */
  ;
  _proto.getVotingSettings =
  /*#__PURE__*/
  function () {
    var _getVotingSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(pluginAddress) {
      var query, params, name, _yield$this$graphql$r, multisigPlugin;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            if (isAddress(pluginAddress)) {
              _context8.next = 2;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 2:
            query = QueryMultisigVotingSettings;
            params = {
              address: pluginAddress.toLowerCase()
            };
            name = "Multisig settings";
            _context8.next = 7;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 7:
            _yield$this$graphql$r = _context8.sent;
            multisigPlugin = _yield$this$graphql$r.multisigPlugin;
            return _context8.abrupt("return", {
              onlyListed: multisigPlugin.onlyListed,
              minApprovals: multisigPlugin.minApprovals
            });
          case 10:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this);
    }));
    function getVotingSettings(_x4) {
      return _getVotingSettings.apply(this, arguments);
    }
    return getVotingSettings;
  }()
  /**
   * returns the members of the multisig
   *
   * @param {string} addressOrEns
   * @return {*}  {Promise<string[]>}
   * @memberof MultisigClientMethods
   */
  ;
  _proto.getMembers =
  /*#__PURE__*/
  function () {
    var _getMembers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(pluginAddress) {
      var query, params, name, _yield$this$graphql$r2, multisigPlugin;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            if (isAddress(pluginAddress)) {
              _context9.next = 2;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 2:
            query = QueryMultisigMembers;
            params = {
              address: pluginAddress.toLowerCase()
            };
            name = "Multisig members";
            _context9.next = 7;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 7:
            _yield$this$graphql$r2 = _context9.sent;
            multisigPlugin = _yield$this$graphql$r2.multisigPlugin;
            return _context9.abrupt("return", multisigPlugin.members.map(function (member) {
              return member.address;
            }));
          case 10:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this);
    }));
    function getMembers(_x5) {
      return _getMembers.apply(this, arguments);
    }
    return getMembers;
  }()
  /**
   * Returns the details of the given proposal
   *
   * @param {string} proposalId
   * @return {*}  {(Promise<MultisigProposal | null>)}
   * @memberof MultisigClientMethods
   */
  ;
  _proto.getProposal =
  /*#__PURE__*/
  function () {
    var _getProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(proposalId) {
      var extendedProposalId, query, params, name, _yield$this$graphql$r3, multisigProposal, metadataCid, metadataString, metadata;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            if (isProposalId(proposalId)) {
              _context10.next = 2;
              break;
            }
            throw new InvalidProposalIdError();
          case 2:
            extendedProposalId = getExtendedProposalId(proposalId);
            query = QueryMultisigProposal;
            params = {
              proposalId: extendedProposalId
            };
            name = "Multisig proposal";
            _context10.next = 8;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 8:
            _yield$this$graphql$r3 = _context10.sent;
            multisigProposal = _yield$this$graphql$r3.multisigProposal;
            if (multisigProposal) {
              _context10.next = 14;
              break;
            }
            return _context10.abrupt("return", null);
          case 14:
            if (multisigProposal.metadata) {
              _context10.next = 16;
              break;
            }
            return _context10.abrupt("return", toMultisigProposal(multisigProposal, EMPTY_PROPOSAL_METADATA_LINK));
          case 16:
            _context10.prev = 16;
            metadataCid = resolveIpfsCid(multisigProposal.metadata);
            _context10.next = 20;
            return this.ipfs.fetchString(metadataCid);
          case 20:
            metadataString = _context10.sent;
            metadata = JSON.parse(metadataString);
            return _context10.abrupt("return", toMultisigProposal(multisigProposal, metadata));
          case 25:
            _context10.prev = 25;
            _context10.t0 = _context10["catch"](16);
            if (!(_context10.t0 instanceof InvalidCidError)) {
              _context10.next = 29;
              break;
            }
            return _context10.abrupt("return", toMultisigProposal(multisigProposal, UNSUPPORTED_PROPOSAL_METADATA_LINK));
          case 29:
            return _context10.abrupt("return", toMultisigProposal(multisigProposal, UNAVAILABLE_PROPOSAL_METADATA));
          case 30:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this, [[16, 25]]);
    }));
    function getProposal(_x6) {
      return _getProposal.apply(this, arguments);
    }
    return getProposal;
  }()
  /**
   * Returns a list of proposals on the Plugin, filtered by the given criteria
   *
   * @param {ProposalQueryParams} {
   *       daoAddressOrEns,
   *       limit = 10,
   *       status,
   *       skip = 0,
   *       direction = SortDirection.ASC,
   *       sortBy = ProposalSortBy.CREATED_AT,
   *     }
   * @return {*}  {Promise<MultisigProposalListItem[]>}
   * @memberof MultisigClientMethods
   */
  ;
  _proto.getProposals =
  /*#__PURE__*/
  function () {
    var _getProposals = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_ref) {
      var _this5 = this;
      var daoAddressOrEns, _ref$limit, limit, status, _ref$skip, skip, _ref$direction, direction, _ref$sortBy, sortBy, where, address, provider, resolvedAddress, query, params, name, _yield$this$graphql$r4, multisigProposals;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            daoAddressOrEns = _ref.daoAddressOrEns, _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? 10 : _ref$limit, status = _ref.status, _ref$skip = _ref.skip, skip = _ref$skip === void 0 ? 0 : _ref$skip, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? SortDirection.ASC : _ref$direction, _ref$sortBy = _ref.sortBy, sortBy = _ref$sortBy === void 0 ? ProposalSortBy.CREATED_AT : _ref$sortBy;
            where = {};
            address = daoAddressOrEns;
            if (!address) {
              _context12.next = 23;
              break;
            }
            if (isAddress(address)) {
              _context12.next = 22;
              break;
            }
            _context12.next = 7;
            return this.web3.ensureOnline();
          case 7:
            provider = this.web3.getProvider();
            if (provider) {
              _context12.next = 10;
              break;
            }
            throw new NoProviderError();
          case 10:
            _context12.prev = 10;
            _context12.next = 13;
            return provider.resolveName(address);
          case 13:
            resolvedAddress = _context12.sent;
            if (resolvedAddress) {
              _context12.next = 16;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 16:
            address = resolvedAddress;
            _context12.next = 22;
            break;
          case 19:
            _context12.prev = 19;
            _context12.t0 = _context12["catch"](10);
            throw new InvalidAddressOrEnsError(_context12.t0);
          case 22:
            where = {
              dao: address.toLowerCase()
            };
          case 23:
            if (status) {
              where = _extends({}, where, computeProposalStatusFilter(status));
            }
            query = QueryMultisigProposals;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "Multisig proposals";
            _context12.next = 29;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 29:
            _yield$this$graphql$r4 = _context12.sent;
            multisigProposals = _yield$this$graphql$r4.multisigProposals;
            return _context12.abrupt("return", Promise.all(multisigProposals.map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(proposal) {
                var metadataCid, stringMetadata, metadata;
                return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                  while (1) switch (_context11.prev = _context11.next) {
                    case 0:
                      if (proposal.metadata) {
                        _context11.next = 2;
                        break;
                      }
                      return _context11.abrupt("return", toMultisigProposalListItem(proposal, EMPTY_PROPOSAL_METADATA_LINK));
                    case 2:
                      _context11.prev = 2;
                      metadataCid = resolveIpfsCid(proposal.metadata);
                      _context11.next = 6;
                      return _this5.ipfs.fetchString(metadataCid);
                    case 6:
                      stringMetadata = _context11.sent;
                      metadata = JSON.parse(stringMetadata);
                      return _context11.abrupt("return", toMultisigProposalListItem(proposal, metadata));
                    case 11:
                      _context11.prev = 11;
                      _context11.t0 = _context11["catch"](2);
                      if (!(_context11.t0 instanceof InvalidCidError)) {
                        _context11.next = 15;
                        break;
                      }
                      return _context11.abrupt("return", toMultisigProposalListItem(proposal, UNSUPPORTED_PROPOSAL_METADATA_LINK));
                    case 15:
                      return _context11.abrupt("return", toMultisigProposalListItem(proposal, UNAVAILABLE_PROPOSAL_METADATA));
                    case 16:
                    case "end":
                      return _context11.stop();
                  }
                }, _callee11, null, [[2, 11]]);
              }));
              return function (_x8) {
                return _ref2.apply(this, arguments);
              };
            }())));
          case 32:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this, [[10, 19]]);
    }));
    function getProposals(_x7) {
      return _getProposals.apply(this, arguments);
    }
    return getProposals;
  }();
  return MultisigClientMethods;
}(ClientCore);

// @ts-ignore
// TODO update with function names
var AVAILABLE_FUNCTION_SIGNATURES$3 = [/*#__PURE__*/Multisig__factory.createInterface().getFunction("addAddresses").format("minimal"), /*#__PURE__*/Multisig__factory.createInterface().getFunction("removeAddresses").format("minimal"), /*#__PURE__*/Multisig__factory.createInterface().getFunction("updateMultisigSettings").format("minimal")];

/**
 * Decoding module for the SDK AddressList Client
 */
var MultisigClientDecoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(MultisigClientDecoding, _ClientCore);
  function MultisigClientDecoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = MultisigClientDecoding.prototype;
  /**
   * Decodes a list of addresses from an encoded add members action
   *
   * @param {Uint8Array} data
   * @return {*}  {string[]}
   * @memberof MultisigClientDecoding
   */
  _proto.addAddressesAction = function addAddressesAction(data) {
    var multisigInterface = Multisig__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedfunction = multisigInterface.getFunction("addAddresses");
    var result = multisigInterface.decodeFunctionData(expectedfunction, hexBytes);
    return result[0];
  }
  /**
   * Decodes a list of addresses from an encoded remove members action
   *
   * @param {Uint8Array} data
   * @return {*}  {string[]}
   * @memberof MultisigClientDecoding
   */;
  _proto.removeAddressesAction = function removeAddressesAction(data) {
    var multisigInterface = Multisig__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedfunction = multisigInterface.getFunction("removeAddresses");
    var result = multisigInterface.decodeFunctionData(expectedfunction, hexBytes);
    return result[0];
  }
  /**
   * Decodes a list of min approvals from an encoded update min approval action
   *
   * @param {Uint8Array} data
   * @return {*}  {MultisigVotingSettings}
   * @memberof MultisigClientDecoding
   */;
  _proto.updateMultisigVotingSettings = function updateMultisigVotingSettings(data) {
    var multisigInterface = Multisig__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedfunction = multisigInterface.getFunction("updateMultisigSettings");
    var result = multisigInterface.decodeFunctionData(expectedfunction, hexBytes);
    return {
      minApprovals: result[0].minApprovals,
      onlyListed: result[0].onlyListed
    };
  }
  /**
   * Returns the decoded function info given the encoded data of an action
   *
   * @param {Uint8Array} data
   * @return {*}  {(InterfaceParams | null)}
   * @memberof MultisigClientDecoding
   */;
  _proto.findInterface = function findInterface(data) {
    try {
      var func = getFunctionFragment(data, AVAILABLE_FUNCTION_SIGNATURES$3);
      return {
        id: func.format("minimal"),
        functionName: func.name,
        hash: bytesToHex(data).substring(0, 10)
      };
    } catch (_unused) {
      return null;
    }
  };
  return MultisigClientDecoding;
}(ClientCore);

/**
 * Estimation module the SDK Address List Client
 */
var MultisigClientEstimation = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(MultisigClientEstimation, _ClientCore);
  function MultisigClientEstimation() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = MultisigClientEstimation.prototype;
  /**
   * Estimates the gas fee of creating a proposal on the plugin
   *
   * @param {CreateMultisigProposalParams} params
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof MultisigClientEstimation
   */
  _proto.createProposal =
  /*#__PURE__*/
  function () {
    var _createProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var _params$failSafeActio, _params$actions, _params$startDate, _params$endDate;
      var signer, multisigContract, allowFailureMap, startTimestamp, endTimestamp, estimation;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            multisigContract = Multisig__factory.connect(params.pluginAddress, signer);
            if (!((_params$failSafeActio = params.failSafeActions) != null && _params$failSafeActio.length && params.failSafeActions.length !== ((_params$actions = params.actions) == null ? void 0 : _params$actions.length))) {
              _context.next = 4;
              break;
            }
            throw new Error("Size mismatch: actions and failSafeActions should match");
          case 4:
            allowFailureMap = boolArrayToBitmap(params.failSafeActions);
            startTimestamp = ((_params$startDate = params.startDate) == null ? void 0 : _params$startDate.getTime()) || 0;
            endTimestamp = ((_params$endDate = params.endDate) == null ? void 0 : _params$endDate.getTime()) || 0;
            _context.next = 9;
            return multisigContract.estimateGas.createProposal(toUtf8Bytes(params.metadataUri), params.actions || [], allowFailureMap, params.approve || false, params.tryExecution || true, Math.round(startTimestamp / 1000), Math.round(endTimestamp / 1000));
          case 9:
            estimation = _context.sent;
            return _context.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function createProposal(_x) {
      return _createProposal.apply(this, arguments);
    }
    return createProposal;
  }()
  /**
   * Estimates the gas fee of approving a proposal
   *
   * @param {ApproveMultisigProposalParams} params
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof MultisigClientEstimation
   */
  ;
  _proto.approveProposal =
  /*#__PURE__*/
  function () {
    var _approveProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var signer, _decodeProposalId, pluginAddress, id, multisigContract, estimation;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _decodeProposalId = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId.pluginAddress, id = _decodeProposalId.id;
            multisigContract = Multisig__factory.connect(pluginAddress, signer);
            _context2.next = 5;
            return multisigContract.estimateGas.approve(id, params.tryExecution);
          case 5:
            estimation = _context2.sent;
            return _context2.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function approveProposal(_x2) {
      return _approveProposal.apply(this, arguments);
    }
    return approveProposal;
  }()
  /**
   * Estimates the gas fee of executing a proposal
   *
   * @param {string} proposalId
   * @return {*}  {Promise<GasFeeEstimation>}
   * @memberof MultisigClientEstimation
   */
  ;
  _proto.executeProposal =
  /*#__PURE__*/
  function () {
    var _executeProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(proposalId) {
      var signer, _decodeProposalId2, pluginAddress, id, multisigContract, estimation;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _decodeProposalId2 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId2.pluginAddress, id = _decodeProposalId2.id;
            multisigContract = Multisig__factory.connect(pluginAddress, signer);
            _context3.next = 5;
            return multisigContract.estimateGas.execute(id);
          case 5:
            estimation = _context3.sent;
            return _context3.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 7:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function executeProposal(_x3) {
      return _executeProposal.apply(this, arguments);
    }
    return executeProposal;
  }();
  return MultisigClientEstimation;
}(ClientCore);

/**
 * Provider a generic client with high level methods to manage and interact an Address List Voting plugin installed in a DAO
 */
var MultisigClient = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(MultisigClient, _ClientCore);
  function MultisigClient(context) {
    var _this;
    _this = _ClientCore.call(this, context) || this;
    _this.methods = new MultisigClientMethods(context);
    _this.encoding = new MultisigClientEncoding(context);
    _this.decoding = new MultisigClientDecoding(context);
    _this.estimation = new MultisigClientEstimation(context);
    return _this;
  }
  return MultisigClient;
}(ClientCore);
MultisigClient.encoding = {
  /**
   * Computes the parameters to be given when creating the DAO,
   * so that the plugin is configured
   *
   * @param {MultisigPluginInstallParams} params
   * @param {Networkish} [network="mainnet"]
   * @return {*}  {PluginInstallItem}
   * @memberof MultisigClient
   */
  getPluginInstallItem: function getPluginInstallItem(params, network) {
    if (network === void 0) {
      network = "mainnet";
    }
    return MultisigClientEncoding.getPluginInstallItem(params, network);
  }
};

export { AddresslistVotingClient, ApproveProposalStep, AssetBalanceSortBy, Client, ClientCore, Context, ContextPlugin, DaoCreationSteps, DaoDepositSteps, DaoRole, DaoSortBy, EMPTY_PROPOSAL_METADATA_LINK, ExecuteProposalStep, LIVE_CONTRACTS, MultisigClient, PermissionIds, PermissionOperationType, Permissions, PluginSortBy, PrepareInstallationStep, PrepareUninstallationSteps, ProposalCreationSteps, ProposalSortBy, ProposalStatus, SetAllowanceSteps, SortDirection, SubgraphVoteValues, SubgraphVoteValuesMap, SupportedNetwork, SupportedNetworksArray, TokenType, TokenVotingClient, TransferSortBy, TransferType, UNAVAILABLE_PROPOSAL_METADATA, UNSUPPORTED_PROPOSAL_METADATA_LINK, UnwrapTokensStep, VoteProposalStep, VoteValues, VotingMode, WrapTokensStep, computeProposalStatus, computeProposalStatusFilter, decodeUpdatePluginSettingsAction, encodeUpdateVotingSettingsAction, findLog, getFunctionFragment, unwrapProposalParams, votingModeFromContracts, votingModeToContracts, votingSettingsToContract };
//# sourceMappingURL=sdk-client.esm.js.map
