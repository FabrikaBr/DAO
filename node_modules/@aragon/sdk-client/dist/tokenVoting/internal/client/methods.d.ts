import { CanVoteParams, ClientCore, CreateMajorityVotingProposalParams, ExecuteProposalStepValue, PrepareInstallationStepValue, ProposalCreationStepValue, ProposalMetadata, ProposalQueryParams, VoteProposalParams, VoteProposalStepValue, VotingSettings } from "../../../client-common";
import { DelegateTokensParams, DelegateTokensStepValue, Erc20TokenDetails, Erc721TokenDetails, TokenVotingMember, TokenVotingPluginPrepareInstallationParams, TokenVotingProposal, TokenVotingProposalListItem, UndelegateTokensStepValue, UnwrapTokensParams, UnwrapTokensStepValue, WrapTokensParams, WrapTokensStepValue } from "../../types";
import { ITokenVotingClientMethods } from "../../interfaces";
/**
 * Methods module the SDK TokenVoting Client
 */
export declare class TokenVotingClientMethods extends ClientCore implements ITokenVotingClientMethods {
    /**
     * Creates a new proposal on the given TokenVoting plugin contract
     *
     * @param {CreateMajorityVotingProposalParams} params
     * @return {*}  {AsyncGenerator<ProposalCreationStepValue>}
     * @memberof TokenVotingClient
     */
    createProposal(params: CreateMajorityVotingProposalParams): AsyncGenerator<ProposalCreationStepValue>;
    /**
     * Pins a metadata object into IPFS and retruns the generated hash
     *
     * @param {ProposalMetadata} params
     * @return {*}  {Promise<string>}
     * @memberof ClientMethods
     */
    pinMetadata(params: ProposalMetadata): Promise<string>;
    /**
     * Cast a vote on the given proposal using the client's wallet. Depending on the proposal settings, an affirmative vote may execute the proposal's actions on the DAO.
     *
     * @param {VoteProposalParams} params
     * @param {VoteValues} vote
     * @return {*}  {AsyncGenerator<VoteProposalStepValue>}
     * @memberof TokenVotingClient
     */
    voteProposal(params: VoteProposalParams): AsyncGenerator<VoteProposalStepValue>;
    /**
     * Executes the given proposal, provided that it has already passed
     *
     * @param {string} proposalId
     * @return {*}  {AsyncGenerator<ExecuteProposalStepValue>}
     * @memberof TokenVotingClient
     */
    executeProposal(proposalId: string): AsyncGenerator<ExecuteProposalStepValue>;
    /**
     * Prepares the installation of a token voting plugin in a given dao
     *
     * @param {TokenVotingPluginPrepareInstallationParams} params
     * @return {*}  {AsyncGenerator<PrepareInstallationStepValue>}
     * @memberof TokenVotingClientMethods
     */
    prepareInstallation(params: TokenVotingPluginPrepareInstallationParams): AsyncGenerator<PrepareInstallationStepValue>;
    wrapTokens(params: WrapTokensParams): AsyncGenerator<WrapTokensStepValue>;
    unwrapTokens(params: UnwrapTokensParams): AsyncGenerator<UnwrapTokensStepValue>;
    /**
     * Delegates all the signer's voting power to a delegatee
     *
     * @param {DelegateTokensParams} params
     * @return {*}  {AsyncGenerator<DelegateTokensStepValue>}
     * @memberof TokenVotingClientMethods
     */
    delegateTokens(params: DelegateTokensParams): AsyncGenerator<DelegateTokensStepValue>;
    /**
     * Delegates all the signer's tokens back to itself
     *
     * @param {string} tokenAddress
     * @return {*}  {AsyncGenerator<UndelegateTokensStepValue>}
     * @memberof TokenVotingClientMethods
     */
    undelegateTokens(tokenAddress: string): AsyncGenerator<UndelegateTokensStepValue>;
    /**
     * Retrieves the current signer's delegatee for the given token
     *
     * @param {string} tokenAddress
     * @return {*}  {Promise<string | null>}
     * @memberof TokenVotingClientMethods
     */
    getDelegatee(tokenAddress: string): Promise<string | null>;
    /**
     * Checks if an user can vote in a proposal
     *
     * @param {CanVoteParams} params
     * @returns {*}  {Promise<boolean>}
     */
    canVote(params: CanVoteParams): Promise<boolean>;
    /**
     * Checks whether the current proposal can be executed
     *
     * @param {string} proposalId
     * @return {*}  {Promise<boolean>}
     * @memberof TokenVotingClientMethods
     */
    canExecute(proposalId: string): Promise<boolean>;
    /**
     * Returns the list of wallet addresses holding tokens from the underlying Token contract used by the plugin
     *
     * @async
     * @param {string} pluginAddress
     * @return {*}  {Promise<string[]>}
     * @memberof TokenVotingClient
     */
    getMembers(pluginAddress: string): Promise<TokenVotingMember[]>;
    /**
     * Returns the details of the given proposal
     *
     * @param {string} proposalId
     * @return {*}  {Promise<TokenVotingProposal>}
     * @memberof TokenVotingClient
     */
    getProposal(proposalId: string): Promise<TokenVotingProposal | null>;
    /**
     * Returns a list of proposals on the Plugin, filtered by the given criteria
     *
     * @param {ProposalQueryParams} params
     * @return {*}  {Promise<TokenVotingProposalListItem[]>}
     * @memberof TokenVotingClient
     */
    getProposals({ daoAddressOrEns, limit, status, skip, direction, sortBy, }: ProposalQueryParams): Promise<TokenVotingProposalListItem[]>;
    /**
     * Returns the settings of a plugin given the address of the plugin instance
     *
     * @param {string} pluginAddress
     * @return {*}  {Promise<VotingSettings>}
     * @memberof TokenVotingClient
     */
    getVotingSettings(pluginAddress: string): Promise<VotingSettings | null>;
    /**
     * Returns the details of the token used in a specific plugin instance
     *
     * @param {string} pluginAddress
     * @return {*}  {Promise<Erc20TokenDetails | null>}
     * @memberof TokenVotingClient
     */
    getToken(pluginAddress: string): Promise<Erc20TokenDetails | Erc721TokenDetails | null>;
}
